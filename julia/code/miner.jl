using LLVM
using LLVM.Interop
import MCAnalyzer: irgen

const _mod = Ref{LLVM.Module}()

@enum Diffe begin
   Duplicate = 1
   Output = 2
   Constant = 3
end

function hasfieldcount(@nospecialize(dt))
    try
        fieldcount(dt)
    catch
        return false
    end
    return true
end

function whatType(@nospecialize(dt))
    if <:(dt, Array)
        sub = whatType(eltype(dt))
        if sub == "diffe_dup"
            return "diffe_dup"
        elseif sub == "diffe_out"
            return "diffe_dup"
        else
            @assert(sub == "diffe_const")
            return "diffe_const"
        end
    end
    if <:(dt, Real)
        return "diffe_out"
    end
    if <:(dt, Int)
        return "diffe_const"
    end
    if <:(dt, String)
        return "diffe_const"
    end

    if ! hasfieldcount(dt)
        # just be safe for now
        return "diffe_dup"
    end
    @assert(hasfieldcount(dt))
    @assert(isstructtype(dt))
    passpointer = true
    if passpointer
        ty = "diffe_const"
        for (ft, fn) in zip(fieldtypes(dt), fieldnames(dt))
            sub = whatType(ft)
            if sub == "diffe_dup"
                ty = "diffe_dup"
            elseif sub == "diffe_out"
                ty = "diffe_dup"
            else
                @assert(sub == "diffe_const")
            end
        end
        return ty
    else
        ty = "diffe_const"
        for (ft, fn) in zip(fieldtypes(dt), fieldnames(dt))
            sub = whatType(ft)
            if sub == "diffe_dup"
                ty = "diffe_dup"
            elseif sub == "diffe_out"
                if ty != "diffe_dup"
                    ty = "diffe_out"
                end
            else
                @assert(sub == "diffe_const")
            end
        end
        return ty
    end
end
    
@generated function autodiff(f, args...)
    # Obtain the function and all it's dependencies in one handy module
    diffetypes = []
    autodifftypes = Type[f]
    i = 1
    while i <= length(args)
        push!(autodifftypes, args[i])
        dt = whatType(args[i])
        push!(diffetypes, dt)
        if dt == "diffe_dup"
            i+=1
        end
        i+=1
    end
    mod, ccf = irgen(Tuple{autodifftypes...}) 

    ctx = context(mod)
    rettype = convert(LLVMType, Float64)
    argtypes2 = LLVMType[convert(LLVMType, T, true) for T in args]

    # TODO get function type from ccf
    ft2  = LLVM.FunctionType(rettype, argtypes2)

    # create a wrapper Function that we will inline into the llvmcall
    # generated by in the end `call_function`
    llvmf = LLVM.Function(mod, "", ft2)
    push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))
    linkage!(llvmf, LLVM.API.LLVMPrivateLinkage)

    # Create the FunctionType and funtion decleration for the intrinsic
    pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
    ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
    autodiff = LLVM.Function(mod, "llvm.autodiff.p0i8", ftd)

    params = LLVM.Value[]
    i = 1
    j = 1
    llvm_params = parameters(llvmf)
    while j < length(args)
        push!(params, MDString(diffetypes[i]))
        if diffetypes[i] == "diffe_dup"
            push!(params, llvm_params[j])
            j+=1
        end
        push!(params, llvm_params[j])
        j+=1
        i+=1
    end

    Builder(ctx) do builder
        entry = BasicBlock(llvmf, "entry", ctx)
        position!(builder, entry)

        tc = bitcast!(builder, ccf, pt)
        pushfirst!(params, tc)

        val = call!(builder, autodiff, params)

        #if T === Nothing
        #    ret!(builder)
        #else
            ret!(builder, val)
        #end
    end

    _mod[] = mod
    _args = (:(args[$i]) for i in 1:length(args))
    call_function(llvmf, Float64, Tuple{args...}, Expr(:tuple, _args...))
end

function sqcube(x::Array{Float64,1})
    sum(x .* x)
end

ar = [1.0, 2.0]
arp = [0.0, 0.0]
@show sqcube(ar)
@show autodiff(sqcube, ar, arp)
