using LLVM
using LLVM.Interop
import MCAnalyzer: irgen

const _mod = Ref{LLVM.Module}()

@generated function autodiff(f, ::Type{T}, args...) where T
    # Obtain the function and all it's dependencies in one handy module
    sig = Tuple{f, args...}
    mod, ccf = irgen(sig) 

    ctx = context(mod)
    rettype = convert(LLVMType, T)
    argtypes = LLVMType[convert(LLVMType, T) for T in args]

    # TODO get function type from ccf
    ft  = LLVM.FunctionType(rettype, argtypes)

    # create a wrapper Function that we will inline into the llvmcall
    # generated by in the end `call_function`
    llvmf = LLVM.Function(mod, "", ft)
    push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))
    linkage!(llvmf, LLVM.API.LLVMPrivateLinkage)

    # Create the FunctionType and funtion decleration for the intrinsic
    pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
    ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
    autodiff = LLVM.Function(mod, "llvm.autodiff.p0i8", ftd)

    params = LLVM.Value[p for p in parameters(llvmf)]

    Builder(ctx) do builder
        entry = BasicBlock(llvmf, "entry", ctx)
        position!(builder, entry)

        tc = bitcast!(builder, ccf, pt)
        pushfirst!(params, tc)

        val = call!(builder, autodiff, params)
        if T === Nothing
            ret!(builder)
        else
            ret!(builder, val)
        end
    end

    _mod[] = mod
    _args = (:(args[$i]) for i in 1:length(args))
    call_function(llvmf, T, Tuple{args...}, Expr(:tuple, _args...))
end

function jl_f2(f::Float64)
    f * f
end

using InteractiveUtils

g(x) = autodiff(jl_f2, Float64, x)

@show g(1.0)
@show _mod[]
@code_llvm g(1.0)

@show @code_typed g(1.0)
