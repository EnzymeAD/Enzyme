using LLVM
using LLVM.Interop
import MCAnalyzer: irgen

const _mod = Ref{LLVM.Module}()

@enum Diffe begin
   Duplicate = 1
   Output = 2
   Constant = 3
end

function hasfieldcount(@nospecialize(dt))
    try
        fieldcount(dt)
    catch
        return false
    end
    return true
end

function whatType(@nospecialize(dt))
    if <:(dt, Array)
        sub = whatType(eltype(dt))
        if sub == "diffe_dup"
            return "diffe_dup"
        elseif sub == "diffe_out"
            return "diffe_dup"
        else
            @assert(sub == "diffe_const")
            return "diffe_const"
        end
    end
    if <:(dt, Real)
        return "diffe_out"
    end
    if <:(dt, Int)
        return "diffe_const"
    end
    if <:(dt, String)
        return "diffe_const"
    end

    if ! hasfieldcount(dt)
        # just be safe for now
        return "diffe_dup"
    end
    @assert(hasfieldcount(dt))
    @assert(isstructtype(dt))
    passpointer = true
    if passpointer
        ty = "diffe_const"
        for (ft, fn) in zip(fieldtypes(dt), fieldnames(dt))
            sub = whatType(ft)
            if sub == "diffe_dup"
                ty = "diffe_dup"
            elseif sub == "diffe_out"
                ty = "diffe_dup"
            else
                @assert(sub == "diffe_const")
            end
        end
        return ty
    else
        ty = "diffe_const"
        for (ft, fn) in zip(fieldtypes(dt), fieldnames(dt))
            sub = whatType(ft)
            if sub == "diffe_dup"
                ty = "diffe_dup"
            elseif sub == "diffe_out"
                if ty != "diffe_dup"
                    ty = "diffe_out"
                end
            else
                @assert(sub == "diffe_const")
            end
        end
        return ty
    end
end
@generated function autodiff(f, args...)
    # Obtain the function and all it's dependencies in one handy module
    diffetypes = []
    autodifftypes = Type[f]
    i = 1
    while i <= length(args)
        push!(autodifftypes, args[i])
        dt = whatType(args[i])
        push!(diffetypes, dt)
        if dt == "diffe_dup"
            i+=1
        end
        i+=1
    end
    mod, ccf = irgen(Tuple{autodifftypes...}) 

    ctx = context(mod)
    rettype = convert(LLVMType, Float64)
    
    #argtypes2 = LLVMType[convert(LLVMType, T, true) for T in args]
    argtypes2 = LLVMType[]
    
    i = 1
    j = 1
    Base.println(typeof(ccf))
    Base.println(typeof(llvmtype(ccf)))
    Base.println(llvmtype(ccf))
    orig_params = parameters(ccf)
    for p in orig_params
        Base.println(llvmtype(p))
        push!(argtypes2, llvmtype(p))
        if diffetypes[i] == "diffe_dup"
            push!(argtypes2, llvmtype(p))
            i+=2
        else
            i+=1
        end
    end
    Base.println(argtypes2)
    

    # TODO get function type from ccf
    ft2  = LLVM.FunctionType(rettype, argtypes2)

    # create a wrapper Function that we will inline into the llvmcall
    # generated by in the end `call_function`
    llvmf = LLVM.Function(mod, "", ft2)
    push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))
    linkage!(llvmf, LLVM.API.LLVMPrivateLinkage)

    # Create the FunctionType and funtion decleration for the intrinsic
    pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
    ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
    autodiff = LLVM.Function(mod, "llvm.autodiff.p0i8", ftd)

    params = LLVM.Value[]
    i = 1
    j = 1
    llvm_params = parameters(llvmf)
    while j <= length(args)
        push!(params, MDString(diffetypes[i]))
        if diffetypes[i] == "diffe_dup"
            push!(params, llvm_params[j])
            j+=1
        end
        push!(params, llvm_params[j])
        j+=1
        i+=1
    end

    Builder(ctx) do builder
        entry = BasicBlock(llvmf, "entry", ctx)
        position!(builder, entry)

        tc = bitcast!(builder, ccf, pt)
        pushfirst!(params, tc)

        val = call!(builder, autodiff, params)

        #if T === Nothing
        #    ret!(builder)
        #else
            ret!(builder, val)
        #end
    end

    _mod[] = mod
    #@show mod
    _args = (:(args[$i]) for i in 1:length(args))
    call_function(llvmf, Float64, Tuple{args...}, Expr(:tuple, _args...))
end

using InteractiveUtils
using BenchmarkTools

# taylor series for -log(1-x)
# eval at -log(1-1/2) = -log(1/2)
function jl_f1(f::Float64)
	g = 0 * f
	for i = 1:10000000
    	g += f^i / i
	end
	g
end

function jl_f2(f)
	g = 0 * f
	for i = 1:10000000
    	g += f^i / i
	end
	g
end

@show jl_f1(0.5)
@time jl_f1(0.5)

@show autodiff(jl_f1, 0.5)
@time autodiff(jl_f1, 0.5)

using Zygote
Zygote.usetyped = true
@show jl_f1'(0.5)
@time jl_f1'(0.5)

using ReverseDiff
@show ReverseDiff.gradient(jl_f2,0.5)
@time ReverseDiff.gradient(jl_f2,0.5)



using AutoGrad

function jl_f2(f::Param{Float64})
	g = 0 * f
	for i = 1:10000000
    	g += f^i / i
	end
	g
end

gfn = grad(jl_f2)
@show gfn(0.5)
@time gfn(0.5)

#=
=#
