#ifndef _fft_h_
#define _fft_h_

#include <adept.h>
#include <adept_arrays.h>
#include <adept_source.h>
using adept::adouble;

using adept::aVector;

/*
  A classy FFT and Inverse FFT C++ class library

  Author: Tim Molteno, tim@physics.otago.ac.nz

  Based on the article "A Simple and Efficient FFT Implementation in C++" by
  Volodymyr Myrnyy with just a simple Inverse FFT modification.

  Licensed under the GPL v3.
*/

#include <cmath>

inline void swap(double *a, double *b) {
  double temp = *a;
  *a = *b;
  *b = temp;
}

static void recursiveApply(double *__restrict data, size_t N, int iSign) {
  if (N == 1)
    return;
  recursiveApply(data, N / 2, iSign);
  recursiveApply(data + N, N / 2, iSign);

  double wtemp = iSign * sin(M_PI / N);
  double wpi = -iSign * sin(2 * (M_PI / N));
  double wpr = -2.0 * wtemp * wtemp;
  double wr = 1.0;
  double wi = 0.0;

  for (size_t i = 0; i < N; i += 2) {
    size_t iN = i + N;
    double *__restrict ay = &data[i + 1];
    double *__restrict ax = &data[i];
    double *__restrict by = &data[iN + 1];
    double *__restrict bx = &data[iN];

    double tempr = *bx * wr - *by * wi;
    double tempi = *bx * wi + *by * wr;

    *bx = *ax - tempr;
    *by = *ay - tempi;
    *ax += tempr;
    *ay += tempi;

    wtemp = wr;
    wr = wr * (wpr + 1.) - wi * wpi;
    wi = wi * (wpr + 1.) + wtemp * wpi;
  }
}

static void scramble(double *data, size_t N) {
  size_t j = 1;
  for (size_t ii = 0; ii < N; ii++) {
    size_t i = 2 * ii + 1;
    if (j > i) {
      swap(&data[j - 1], &data[i - 1]);
      swap(&data[j], &data[i]);
    }
    size_t m = N;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
}

static void rescale(double *data, size_t N) {
  double scale = ((double)1) / N;
  for (size_t i = 0; i < 2 * N; i++) {
    data[i] *= scale;
  }
}

static void fft(double *data, size_t N) {
  scramble(data, N);
  recursiveApply(data, N, 1);
}

static void ifft(double *data, size_t N) {
  scramble(data, N);
  recursiveApply(data, N, -1);
  rescale(data, N);
}

inline void swapad(adept::ActiveReference<double> a,
                   adept::ActiveReference<double> b) {
  adouble temp = a;
  a = b;
  b = temp;
}

static void recursiveApply(aVector data, size_t N, int iSign) {
  if (N == 1)
    return;
  recursiveApply(data, N / 2, iSign);
  recursiveApply(data(adept::range(N, adept::end)), N / 2, iSign);

  adouble wtemp = iSign * std::sin(M_PI / N);
  adouble wpi = -iSign * std::sin(2 * (M_PI / N));
  adouble wpr = -2.0 * wtemp * wtemp;
  adouble wr = 1.0;
  adouble wi = 0.0;

  for (size_t ii = 0; ii < N / 2; ii++) {
    size_t i = 2 * ii;
    size_t iN = i + N;

    adouble tempr = data(iN) * wr - data(iN + 1) * wi;
    adouble tempi = data(iN) * wi + data(iN + 1) * wr;

    data(iN) = data(i) - tempr;
    data(iN + 1) = data(i + 1) - tempi;
    data(i) += tempr;
    data(i + 1) += tempi;

    wtemp = wr;
    wr = wr * (wpr + 1.) - wi * wpi;
    wi = wi * (wpr + 1.) + wtemp * wpi;
  }
}

static void scramble(aVector data, size_t N) {
  size_t j = 1;
  for (size_t ii = 0; ii < N; ii++) {
    size_t i = 2 * ii + 1;
    if (j > i) {
      swapad(data(j - 1), data(i - 1));
      swapad(data(j), data(i));
    }
    size_t m = N;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
}

static void rescale(aVector data, size_t N) {
  adouble scale = ((double)1) / N;
  for (size_t i = 0; i < 2 * N; i++) {
    data[i] *= scale;
  }
}

static void fft(aVector data, size_t N) {
  scramble(data, N);
  recursiveApply(data, N, 1);
}

static void ifft(aVector data, size_t N) {
  scramble(data, N);
  recursiveApply(data, N, -1);
  rescale(data, N);
}

//! Tapenade
extern "C" {

/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (bugfix_servletAD) -  4 Jan 2024 17:44
*/
#include <adBuffer.h>
#include <adStack.h>
#include <math.h>

/*
  Differentiation of swap in reverse (adjoint) mode:
   gradient     of useful results: *a *b
   with respect to varying inputs: *a *b
   Plus diff mem management of: a:in b:in
*/
inline void swap_b(double *a, double *ab, double *b, double *bb) {
  double temp = *a;
  double tempb = 0.0;
  *a = *b;
  *b = temp;
  tempb = *bb;
  *bb = *ab;
  *ab = tempb;
}

inline void swap_c(double *a, double *b) {
  double temp = *a;
  *a = *b;
  *b = temp;
}

static void recursiveApply_c(double *data, int iSign, size_t N) {
  size_t arg1;
  double *arg10;
  size_t arg2;
  if (N == 1)
    return;
  else {
    arg1 = N / 2;
    recursiveApply_c(data, iSign, arg1);
    arg10 = data + N;
    arg2 = N / 2;
    recursiveApply_c(arg10, iSign, arg2);
    double wtemp = iSign * sin(3.14 / N);
    double wpi = -iSign * sin(2 * 3.14 / N);
    double wpr = -2.0 * wtemp * wtemp;
    double wr = 1.0;
    double wi = 0.0;
    for (size_t ii = 0; ii < N / 2; ii++) {
      size_t i = 2 * ii;
      size_t iN = i + N;
      double tempr = data[iN] * wr - data[iN + 1] * wi;
      double tempi = data[iN] * wi + data[iN + 1] * wr;
      data[iN] = data[i] - tempr;
      data[iN + 1] = data[i + 1] - tempi;
      data[i] += tempr;
      data[i + 1] += tempi;
      wtemp = wr;
      wr += wr * wpr - wi * wpi;
      wi += wi * wpr + wtemp * wpi;
    }
  }
}

/*
  Differentiation of recursiveApply in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   Plus diff mem management of: data:in
*/
static void recursiveApply_b(double *data, double *datab, int iSign, size_t N) {
  size_t arg1;
  double *arg10;
  double *arg10b;
  size_t arg2;
  int branch;
  if (N != 1) {
    arg1 = N / 2;
    pushReal8(*data);
    recursiveApply_c(data, iSign, arg1);
    arg10b = datab + N;
    arg10 = data + N;
    arg2 = N / 2;
    if (arg10) {
      pushReal8(*arg10);
      pushControl1b(1);
    } else
      pushControl1b(0);
    recursiveApply_c(arg10, iSign, arg2);
    double wtemp = iSign * sin(3.14 / N);
    double wpi = -iSign * sin(2 * 3.14 / N);
    double wpr = -2.0 * wtemp * wtemp;
    double wr = 1.0;
    double wi = 0.0;
    for (size_t ii = 0; ii < N / 2; ii++) {
      size_t i = 2 * ii;
      int iN = i + N;
      double tempr = data[iN] * wr - data[iN + 1] * wi;
      double tempi = data[iN] * wi + data[iN + 1] * wr;
      double temprb;
      double tempib;
      double tmp;
      double tmp0;
      tmp = data[i] - tempr;
      data[iN] = tmp;
      tmp0 = data[i + 1] - tempi;
      data[iN + 1] = tmp0;
      data[i] = data[i] + tempr;
      data[i + 1] = data[i + 1] + tempi;
      wtemp = wr;
      pushReal8(wr);
      wr = wr + (wr * wpr - wi * wpi);
      pushReal8(wi);
      wi = wi + (wi * wpr + wtemp * wpi);
      pushInteger4(iN);
    }
    for (size_t i = N - (N - 1) % 2 - 1; i >= 0; i -= 2) {
      int iN;
      double tempr;
      double temprb = 0.0;
      double tempi;
      double tempib = 0.0;
      double tmpb;
      double tmpb0;
      popInteger4(&iN);
      tmpb0 = datab[iN + 1];
      popReal8(&wi);
      popReal8(&wr);
      tempib = datab[i + 1] - tmpb0;
      temprb = datab[i];
      datab[iN + 1] = 0.0;
      datab[i + 1] = datab[i + 1] + tmpb0;
      tmpb = datab[iN];
      datab[iN] = 0.0;
      datab[i] = datab[i] + tmpb;
      temprb = temprb - tmpb;
      datab[iN + 1] = datab[iN + 1] + wr * tempib - wi * temprb;
      datab[iN] = datab[iN] + wi * tempib + wr * temprb;
    }
    popControl1b(&branch);
    if (branch == 1)
      popReal8(arg10);
    recursiveApply_b(arg10, arg10b, iSign, arg2);
    popReal8(data);
    recursiveApply_b(data, datab, iSign, arg1);
  }
}

/*
  Differentiation of scramble in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   Plus diff mem management of: data:in
*/
static void scramble_b(double *data, double *datab, size_t N) {
  int j = 1;
  int branch;
  for (size_t ii = 0; ii < N; ii++) {
    size_t i = 2 * ii + 1;
    int adCount;
    if (j > i) {
      pushReal8(data[i - 1]);
      pushReal8(data[j - 1]);
      swap_c(&(data[j - 1]), &(data[i - 1]));
      pushReal8(data[i]);
      pushReal8(data[j]);
      swap_c(&(data[j]), &(data[i]));
      pushControl1b(0);
    } else
      pushControl1b(1);
    size_t m = N;
    adCount = 0;
    while (m >= 2 && j > m) {
      pushInteger4(j);
      j = j - m;
      m = m >> 1;
      adCount = adCount + 1;
    }
    pushInteger4(adCount);
    pushInteger4(j);
    j = j + m;
  }
  for (size_t i = 2 * N - (2 * N - 2) % 2 - 1; i >= 1; i -= 2) {
    size_t m;
    int adCount;
    size_t i0;
    popInteger4(&j);
    popInteger4(&adCount);
    for (i0 = 1; i0 < adCount + 1; ++i0)
      popInteger4(&j);
    popControl1b(&branch);
    if (branch == 0) {
      popReal8(&(data[j]));
      popReal8(&(data[i]));
      swap_b(&(data[j]), &(datab[j]), &(data[i]), &(datab[i]));
      popReal8(&(data[j - 1]));
      popReal8(&(data[i - 1]));
      swap_b(&(data[j - 1]), &(datab[j - 1]), &(data[i - 1]), &(datab[i - 1]));
    }
  }
}

static void scramble_c(double *data, size_t N) {
  size_t j = 1;
  for (size_t ii = 0; ii < N; ii++) {
    size_t i = 2 * ii + 1;
    if (j > i) {
      swap_c(&(data[j - 1]), &(data[i - 1]));
      swap_c(&(data[j]), &(data[i]));
    }
    size_t m = N;
    while (m >= 2 && j > m) {
      j -= m;
      m >>= 1;
    }
    j += m;
  }
}

/*
  Differentiation of rescale in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   Plus diff mem management of: data:in
*/
static void rescale_b(double *data, double *datab, size_t N) {
  double scale = (double)1 / N;
  for (size_t i = 0; i < 2 * N; ++i)
    data[i] = data[i] * scale;
  for (size_t i = 2 * N - 1; i > -1; --i)
    datab[i] = scale * datab[i];
}

static void rescale_c(double *data, size_t N) {
  double scale = (double)1 / N;
  for (size_t i = 0; i < 2 * N; ++i)
    data[i] *= scale;
}

/*
  Differentiation of fiveft in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   Plus diff mem management of: data:in
*/
void fiveft_b(double *data, double *datab, size_t N) {
  pushReal8(*data);
  scramble_c(data, N);
  pushReal8(*data);
  recursiveApply_c(data, 1, N);
  popReal8(data);
  recursiveApply_b(data, datab, 1, N);
  popReal8(data);
  scramble_b(data, datab, N);
}

void fiveft_c(double *data, size_t N) {
  scramble_c(data, N);
  recursiveApply_c(data, 1, N);
}

/*
  Differentiation of ifiveft in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   Plus diff mem management of: data:in
*/
void ifiveft_b(double *data, double *datab, size_t N) {
  pushReal8(*data);
  scramble_c(data, N);
  pushReal8(*data);
  recursiveApply_c(data, -1, N);
  pushReal8(*data);
  rescale_c(data, N);
  popReal8(data);
  rescale_b(data, datab, N);
  popReal8(data);
  recursiveApply_b(data, datab, -1, N);
  popReal8(data);
  scramble_b(data, datab, N);
}

void ifiveft_c(double *data, size_t N) {
  scramble_c(data, N);
  recursiveApply_c(data, -1, N);
  rescale_c(data, N);
}

/*
  Differentiation of foobar in reverse (adjoint) mode:
   gradient     of useful results: *data
   with respect to varying inputs: *data
   RW status of diff variables: data:(loc) *data:in-out
   Plus diff mem management of: data:in
*/
void foobar_b(double *data, double *datab, size_t len) {
  pushReal8(*data);
  fiveft_c(data, len);
  pushReal8(*data);
  ifiveft_c(data, len);
  popReal8(data);
  ifiveft_b(data, datab, len);
  popReal8(data);
  fiveft_b(data, datab, len);
}
}

#endif /* _fft_h_ */
