// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*
 *   File "lstm_b_tapenade_generated.c" is generated by Tapenade 3.14 (r7259)
 * from this file. To reproduce such a generation you can use Tapenade CLI (can
 * be downloaded from http://www-sop.inria.fr/tropics/tapenade/downloading.html)
 *
 *   After installing use the next command to generate a file:
 *
 *      tapenade -b -o lstm_tapenade -head "lstm_objective(loss)/(main_params
 * extra_params)" lstm.c
 *
 *   This will produce a file "lstm_tapenade_b.c" which content will be the same
 * as the content of the file "lstm_b_tapenade_generated.c", except one-line
 * header. Moreover a log-file "lstm_tapenade_b.msg" will be produced.
 *
 *   NOTE: the code in "lstm_b_tapenade_generated.c" is wrong and won't work.
 *         REPAIRED SOURCE IS STORED IN THE FILE "lstm_b.c".
 *         You can either use diff tool or read "lstm_b.c" header to figure out
 * what changes was performed to fix the code.
 *
 *   NOTE: you can also use Tapenade web server
 * (http://tapenade.inria.fr:8080/tapenade/index.jsp) for generating but the
 * result can be slightly different.
 */

#include "../adbench/lstm.h"

// Enzyme Forward-Mode
extern "C" {
#include "lstm.h"

// UTILS
// Sigmoid on scalar
double sigmoid(double x) { return 1.0 / (1.0 + exp(-x)); }

// log(sum(exp(x), 2))
double logsumexp(double const *vect, int sz) {
  double sum = 0.0;
  int i;

  for (i = 0; i < sz; i++) {
    sum += exp(vect[i]);
  }

  sum += 2;
  return log(sum);
}

// LSTM OBJECTIVE
// The LSTM model
void lstm_model(int hsize, double const *__restrict weight,
                double const *__restrict bias, double *__restrict hidden,
                double *__restrict cell, double const *__restrict input) {
  // TODO NOTE THIS
  //__builtin_assume(hsize > 0);

  double *gates = (double *)malloc(4 * hsize * sizeof(double));
  double *forget = &(gates[0]);
  double *ingate = &(gates[hsize]);
  double *outgate = &(gates[2 * hsize]);
  double *change = &(gates[3 * hsize]);

  int i;
  // caching input
  // hidden (needed)
  for (i = 0; i < hsize; i++) {
    forget[i] = sigmoid(input[i] * weight[i] + bias[i]);
    ingate[i] = sigmoid(hidden[i] * weight[hsize + i] + bias[hsize + i]);
    outgate[i] =
        sigmoid(input[i] * weight[2 * hsize + i] + bias[2 * hsize + i]);
    change[i] = tanh(hidden[i] * weight[3 * hsize + i] + bias[3 * hsize + i]);
  }

  // caching cell (needed)
  for (i = 0; i < hsize; i++) {
    cell[i] = cell[i] * forget[i] + ingate[i] * change[i];
  }

  for (i = 0; i < hsize; i++) {
    hidden[i] = outgate[i] * tanh(cell[i]);
  }

  free(gates);
}

// Predict LSTM output given an input
void lstm_predict(int l, int b, double const *__restrict w,
                  double const *__restrict w2, double *__restrict s,
                  double const *__restrict x, double *__restrict x2) {
  int i;
  for (i = 0; i < b; i++) {
    x2[i] = x[i] * w2[i];
  }

  double *xp = x2;
  for (i = 0; i <= 2 * l * b - 1; i += 2 * b) {
    lstm_model(b, &(w[i * 4]), &(w[(i + b) * 4]), &(s[i]), &(s[i + b]), xp);
    xp = &(s[i]);
  }

  for (i = 0; i < b; i++) {
    x2[i] = xp[i] * w2[b + i] + w2[2 * b + i];
  }
}

// LSTM objective (loss function)
void lstm_objective(int l, int c, int b, double const *__restrict main_params,
                    double const *__restrict extra_params,
                    double *__restrict state, double const *__restrict sequence,
                    double *__restrict loss) {
  int i, t;
  double total = 0.0;
  int count = 0;
  const double *input = &(sequence[0]);
  double *ypred = (double *)malloc(b * sizeof(double));
  double *ynorm = (double *)malloc(b * sizeof(double));
  const double *ygold;
  double lse;

  __builtin_assume(b > 0);
  for (t = 0; t <= (c - 1) * b - 1; t += b) {
    lstm_predict(l, b, main_params, extra_params, state, input, ypred);
    lse = logsumexp(ypred, b);
    for (i = 0; i < b; i++) {
      ynorm[i] = ypred[i] - lse;
    }

    ygold = &(sequence[t + b]);
    for (i = 0; i < b; i++) {
      total += ygold[i] * ynorm[i];
    }

    count += b;
    input = ygold;
  }

  *loss = -total / count;

  free(ypred);
  free(ynorm);
}

extern int enzyme_const;
extern int enzyme_dup;
extern int enzyme_dupv;
extern int enzyme_dupnoneed;
extern int enzyme_dupnoneedv;
extern int enzyme_width;

void __enzyme_fwddiff(...) noexcept;
void __enzyme_fwddiff_vec(...) noexcept;


void dlstm_objective(int l, int c, int b, double const *__restrict main_params,
                     double *__restrict dmain_params, double const *__restrict extra_params,
                     double *__restrict dextra_params, double *__restrict state,
                     double const *__restrict sequence, double *__restrict loss, double *__restrict dloss) {
  __enzyme_fwddiff(lstm_objective, enzyme_const, l, enzyme_const, c,
                   enzyme_const, b, enzyme_dup, main_params, dmain_params,
                   enzyme_dup, extra_params, dextra_params, enzyme_const, state,
                   enzyme_const, sequence, enzyme_dupnoneed, loss, dloss);
}
}

template<unsigned vector_width>
void dlstm_objective_vec(int l, int c, int b,
                      double const *__restrict main_params, double *__restrict dmain_params, int main_params_size,
                      double const *__restrict extra_params, double *__restrict dextra_params, int extra_params_size,
                      double *__restrict state, double const *__restrict sequence,
                      double *__restrict loss, double *__restrict dloss) {

  __enzyme_fwddiff_vec(lstm_objective,
       enzyme_width, vector_width,
       enzyme_const, l,
       enzyme_const, c,
       enzyme_const, b,
       enzyme_dupv, main_params_size * sizeof(double), main_params, dmain_params,
       enzyme_dupv, extra_params_size * sizeof(double), extra_params, dextra_params,
       enzyme_const, state,
       enzyme_const, sequence,
       enzyme_dupnoneedv, 1 * sizeof(double), loss, dloss);
}

//! Tapenade
extern "C" {

#include <adBuffer.h>

// UTILS
// Sigmoid on scalar
double sigmoid_d(double x, double xd, double *sigmoid) {
  double temp;
  temp = 1.0 / (exp(-x) + 1.0);
  *sigmoid = temp;
  return temp * exp(-x) * xd / (exp(-x) + 1.0);
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *vect
   Plus diff mem management of: vect:in
*/
// log(sum(exp(x), 2))
double logsumexp_d(const double *vect, const double *vectd, int sz,
                   double *logsumexp) {
  double sum = 0.0;
  double sumd;
  int i;
  sumd = 0.0;
  for (i = 0; i < sz; ++i) {
    sumd = sumd + exp(vect[i]) * vectd[i];
    sum += exp(vect[i]);
  }
  sum += 2;
  *logsumexp = log(sum);
  return sumd / sum;
}

/*
  Differentiation of lstm_model in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *cell *hidden
   with respect to varying inputs: alloc(*gates) *cell *bias *hidden
                *weight *input
   Plus diff mem management of: cell:in bias:in hidden:in weight:in
                input:in
*/
// LSTM OBJECTIVE
// The LSTM model
void lstm_model_d(int hsize, const double *__restrict weight,
                  const double *__restrict weightd,
                  const double *__restrict bias, const double *__restrict biasd,
                  double *__restrict hidden, double *__restrict hiddend,
                  double *__restrict cell, double *__restrict celld,
                  const double *__restrict input,
                  const double *__restrict inputd) {
  // TODO NOTE THIS
  //__builtin_assume(hsize > 0);
  double *gates;
  double *gatesd;
  int ii1;
  double temp;
  double temp0;
  gatesd = (double *)malloc(4 * hsize * sizeof(double));
  for (ii1 = 0; ii1 < 4 * hsize; ++ii1)
    gatesd[ii1] = 0.0;
  gates = (double *)malloc(4 * hsize * sizeof(double));
  double *forget = &(gates[0]);
  double *forgetd = &(gatesd[0]);
  double *ingate = &(gates[hsize]);
  double *ingated = &(gatesd[hsize]);
  double *outgate = &(gates[2 * hsize]);
  double *outgated = &(gatesd[2 * hsize]);
  double *change = &(gates[3 * hsize]);
  double *changed = &(gatesd[3 * hsize]);
  int i;
  // caching input
  // hidden (needed)
  for (i = 0; i < hsize; ++i) {
    forgetd[i] = sigmoid_d(
        input[i] * weight[i] + bias[i],
        weight[i] * inputd[i] + input[i] * weightd[i] + biasd[i], &(forget[i]));
    ingated[i] =
        sigmoid_d(hidden[i] * weight[hsize + i] + bias[hsize + i],
                  weight[hsize + i] * hiddend[i] +
                      hidden[i] * weightd[hsize + i] + biasd[hsize + i],
                  &(ingate[i]));
    temp = weight[2 * hsize + i];
    outgated[i] =
        sigmoid_d(input[i] * weight[2 * hsize + i] + bias[2 * hsize + i],
                  temp * inputd[i] + input[i] * weightd[2 * hsize + i] +
                      biasd[2 * hsize + i],
                  &(outgate[i]));
    temp = weight[3 * hsize + i];
    temp0 = hidden[i] * temp + bias[3 * hsize + i];
    changed[i] = (1.0 - tanh(temp0) * tanh(temp0)) *
                 (temp * hiddend[i] + hidden[i] * weightd[3 * hsize + i] +
                  biasd[3 * hsize + i]);
    change[i] = tanh(temp0);
  }
  // caching cell (needed)
  for (i = 0; i < hsize; ++i) {
    celld[i] = forget[i] * celld[i] + cell[i] * forgetd[i] +
               change[i] * ingated[i] + ingate[i] * changed[i];
    cell[i] = cell[i] * forget[i] + ingate[i] * change[i];
  }
  for (i = 0; i < hsize; ++i) {
    temp0 = tanh(cell[i]);
    hiddend[i] = temp0 * outgated[i] +
                 outgate[i] * (1.0 - tanh(cell[i]) * tanh(cell[i])) * celld[i];
    hidden[i] = outgate[i] * temp0;
  }
  free(gatesd);
  free(gates);
}

/*
  Differentiation of lstm_predict in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *s *x2
   with respect to varying inputs: alloc(*gates) *s *w *w2 *x2
   Plus diff mem management of: s:in w:in w2:in x2:in
*/
// Predict LSTM output given an input
void lstm_predict_d(int l, int b, const double *__restrict w,
                    const double *__restrict wd, const double *__restrict w2,
                    const double *__restrict w2d, double *__restrict s,
                    double *__restrict sd, const double *__restrict x,
                    double *__restrict x2, double *__restrict x2d) {
  int i;
  for (i = 0; i < b; ++i) {
    x2d[i] = x[i] * w2d[i];
    x2[i] = x[i] * w2[i];
  }
  double *xp = x2;
  double *xpd = x2d;
  for (i = 0; i <= 2 * l * b - 1; i += 2 * b) {
    lstm_model_d(b, &(w[i * 4]), &(wd[i * 4]), &(w[(i + b) * 4]),
                 &(wd[(i + b) * 4]), &(s[i]), &(sd[i]), &(s[i + b]),
                 &(sd[i + b]), xp, xpd);
    xpd = &(sd[i]);
    xp = &(s[i]);
  }
  for (i = 0; i < b; ++i) {
    x2d[i] = w2[b + i] * xpd[i] + xp[i] * w2d[b + i] + w2d[2 * b + i];
    x2[i] = xp[i] * w2[b + i] + w2[2 * b + i];
  }
}

/*
  Differentiation of lstm_objective in forward (tangent) mode:
   variations   of useful results: *loss
   with respect to varying inputs: *main_params *extra_params
   RW status of diff variables: main_params:(loc) *main_params:in
                extra_params:(loc) *extra_params:in loss:(loc)
                *loss:out
   Plus diff mem management of: main_params:in extra_params:in
                loss:in state:in
*/
// LSTM objective (loss function)
void lstm_objective_d(int l, int c, int b, const double *__restrict main_params,
                      double *__restrict main_paramsd,
                      const double *__restrict extra_params,
                      double *__restrict extra_paramsd,
                      double *__restrict state,
                      const double *__restrict sequence,
                      double *__restrict loss, double *__restrict lossd) {
  int i, t;
  int main_sz = 2 * l * 4 * b;
  int extra_sz = 3 * b;
  int state_sz = 2 * l * b;
  int seq_sz = c * b;
  double *stated = (double *)malloc(state_sz * sizeof(double));
  double total = 0.0;
  double totald;
  int count = 0;
  const double *input = &(sequence[0]);
  double *ypred;
  double *ypredd;
  ypredd = (double *)malloc(b * sizeof(double));
  ypred = (double *)malloc(b * sizeof(double));
  double *ynorm;
  double *ynormd;
  ynormd = (double *)malloc(b * sizeof(double));
  ynorm = (double *)malloc(b * sizeof(double));
  const double *ygold;
  double lse;
  double lsed;
  __builtin_assume(b > 0);
  *stated = 0.0;
  for (t = 0; t <= (c - 1) * b - 1; t += b) {
    lstm_predict_d(l, b, main_params, main_paramsd, extra_params, extra_paramsd,
                   state, stated, input, ypred, ypredd);
    lsed = logsumexp_d(ypred, ypredd, b, &lse);
    for (i = 0; i < b; ++i) {
      ynormd[i] = ypredd[i] - lsed;
      ynorm[i] = ypred[i] - lse;
    }
    ygold = &(sequence[t + b]);
    for (i = 0; i < b; ++i) {
      totald = totald + ygold[i] * ynormd[i];
      total += ygold[i] * ynorm[i];
    }
    count += b;
    input = ygold;
  }
  *lossd = -(totald / count);
  *loss = -total / count;
  free(ypredd);
  free(ypred);
  free(ynormd);
  free(ynorm);
}
}

// tapenade vector

/*
  Differentiation of sigmoid in forward (tangent) mode:
   variations   of useful results: sigmoid
   with respect to varying inputs: x
*/
// UTILS
// Sigmoid on scalar
template<unsigned NBDirsMax>
void sigmoid_dv(double x, double xd[NBDirsMax], double *sigmoid, double 
        sigmoidd[NBDirsMax], int nbdirs) {
    double temp;
    int nd;
    temp = 1.0/(exp(-x)+1.0);
    *sigmoid = temp;
    for (nd = 0; nd < nbdirs; ++nd)
        sigmoidd[nd] = temp*exp(-x)*xd[nd]/(exp(-x)+1.0);
}

/*
  Differentiation of logsumexp in forward (tangent) mode:
   variations   of useful results: logsumexp
   with respect to varying inputs: *vect
   Plus diff mem management of: vect:in
*/
// log(sum(exp(x), 2))
template<unsigned NBDirsMax>
void logsumexp_dv(const double *vect, const double (*vectd)[NBDirsMax], int sz
        , double *logsumexp, double logsumexpd[NBDirsMax], int nbdirs) {
    double sum;
    double sumd[NBDirsMax];
    int nd;
    sum = 0.0;
    int i;
    for (nd = 0; nd < NBDirsMax; ++nd)
        sumd[nd] = 0.0;
    for (i = 0; i < sz; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            sumd[nd] = sumd[nd] + exp(vect[i])*vectd[i][nd];
        sum += exp(vect[i]);
    }
    sum += 2;
    *logsumexp = log(sum);
    for (nd = 0; nd < nbdirs; ++nd)
        logsumexpd[nd] = sumd[nd]/sum;
}

/*
  Differentiation of lstm_model in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *cell *hidden
   with respect to varying inputs: alloc(*gates) *cell *bias *hidden
                *weight *input
   Plus diff mem management of: cell:in bias:in hidden:in weight:in
                input:in
*/
// LSTM OBJECTIVE
// The LSTM model
template<unsigned NBDirsMax>
void lstm_model_dv(int hsize, const double *__restrict weight, const double (*
        __restrict weightd)[NBDirsMax], const double *__restrict bias, const 
        double (*__restrict biasd)[NBDirsMax], double *__restrict hidden, 
        double (*__restrict hiddend)[NBDirsMax], double *__restrict cell, 
        double (*__restrict celld)[NBDirsMax], const double *__restrict input,
        const double (*__restrict inputd)[NBDirsMax], int nbdirs) {
    double *gates;
    double (* gatesd)[NBDirsMax];
    double arg1;
    double arg1d[NBDirsMax];
    int ii1;
    int nd;
    double temp;
    size_t ssize = 4*hsize*sizeof(double [NBDirsMax])*NBDirsMax;
    gatesd = (double (*)[NBDirsMax])malloc(ssize);
    for (ii1 = 0; ii1 < 4*hsize; ++ii1)
        for (nd = 0; nd < NBDirsMax; ++nd)
            gatesd[ii1][nd] = 0.0;
    gates = (double *)malloc(4*hsize*sizeof(double));
    double *forget;
    double (* forgetd)[NBDirsMax];
    forgetd = &(gatesd[0]);
    forget = &(gates[0]);
    double *ingate;
    double (* ingated)[NBDirsMax];
    ingated = &(gatesd[hsize]);
    ingate = &(gates[hsize]);
    double *outgate;
    double (* outgated)[NBDirsMax];
    outgated = &(gatesd[2*hsize]);
    outgate = &(gates[2*hsize]);
    double *change;
    double (* changed)[NBDirsMax];
    changed = &(gatesd[3*hsize]);
    change = &(gates[3*hsize]);
    int i;
    // caching input
    // hidden (needed)
    for (i = 0; i < hsize; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            arg1d[nd] = weight[i]*inputd[i][nd] + input[i]*weightd[i][nd] + 
                biasd[i][nd];
        arg1 = input[i]*weight[i] + bias[i];
        sigmoid_dv<NBDirsMax>(arg1, arg1d, &(forget[i]), forgetd[i], nbdirs);
        for (nd = 0; nd < nbdirs; ++nd)
            arg1d[nd] = weight[hsize+i]*hiddend[i][nd] + hidden[i]*weightd[
                hsize+i][nd] + biasd[hsize + i][nd];
        arg1 = hidden[i]*weight[hsize+i] + bias[hsize + i];
        sigmoid_dv<NBDirsMax>(arg1, arg1d, &(ingate[i]), ingated[i], nbdirs);
        temp = weight[2*hsize + i];
        for (nd = 0; nd < nbdirs; ++nd)
            arg1d[nd] = temp*inputd[i][nd] + input[i]*weightd[2*hsize+i][nd] +
                biasd[2*hsize + i][nd];
        arg1 = input[i]*temp + bias[2*hsize + i];
        sigmoid_dv<NBDirsMax>(arg1, arg1d, &(outgate[i]), outgated[i], nbdirs);
        temp = weight[3*hsize + i];
        arg1 = hidden[i]*temp + bias[3*hsize + i];
        for (nd = 0; nd < nbdirs; ++nd) {
            arg1d[nd] = temp*hiddend[i][nd] + hidden[i]*weightd[3*hsize+i][nd]
                + biasd[3*hsize + i][nd];
            changed[i][nd] = (1.0-tanh(arg1)*tanh(arg1))*arg1d[nd];
        }
        change[i] = tanh(arg1);
    }
    // caching cell (needed)
    for (i = 0; i < hsize; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            celld[i][nd] = forget[i]*celld[i][nd] + cell[i]*forgetd[i][nd] + 
                change[i]*ingated[i][nd] + ingate[i]*changed[i][nd];
        cell[i] = cell[i]*forget[i] + ingate[i]*change[i];
    }
    for (i = 0; i < hsize; ++i) {
        temp = tanh(cell[i]);
        for (nd = 0; nd < nbdirs; ++nd)
            hiddend[i][nd] = temp*outgated[i][nd] + outgate[i]*(1.0-tanh(cell[
                i])*tanh(cell[i]))*celld[i][nd];
        hidden[i] = outgate[i]*temp;
    }
    free(gatesd);
    free(gates);
}

/*
  Differentiation of lstm_predict in forward (tangent) mode:
   variations   of useful results: alloc(*gates) *s *x2
   with respect to varying inputs: alloc(*gates) *s *w *w2 *x2
   Plus diff mem management of: s:in w:in w2:in x2:in
*/
// Predict LSTM output given an input
template<unsigned NBDirsMax>
void lstm_predict_dv(int l, int b, const double *__restrict w, const double (*
        __restrict wd)[NBDirsMax], const double *__restrict w2, const double (
        *__restrict w2d)[NBDirsMax], double *__restrict s, double (*__restrict
        sd)[NBDirsMax], const double *__restrict x, double *__restrict x2, 
        double (*__restrict x2d)[NBDirsMax], int nbdirs) {
    int i;
    int nd;
    for (i = 0; i < b; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            x2d[i][nd] = x[i]*w2d[i][nd];
        x2[i] = x[i]*w2[i];
    }
    double *xp;
    double (* xpd)[NBDirsMax];
    xpd = x2d;
    xp = x2;
    for (i = 0; i <= 2*l*b-1; i += 2*b) {
        lstm_model_dv(b, &(w[i*4]), &(wd[i*4]), &(w[(i+b)*4]), &(wd[(i+b)*4]),
                      &(s[i]), &(sd[i]), &(s[i + b]), &(sd[i + b]), xp, xpd, 
                      nbdirs);
        xpd = &(sd[i]);
        xp = &(s[i]);
    }
    for (i = 0; i < b; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            x2d[i][nd] = w2[b+i]*xpd[i][nd] + xp[i]*w2d[b+i][nd] + w2d[2*b + i
                ][nd];
        x2[i] = xp[i]*w2[b+i] + w2[2*b + i];
    }
}

/*
  Differentiation of lstm_objective in forward (tangent) mode:
   variations   of useful results: *loss
   with respect to varying inputs: *main_params *extra_params
   RW status of diff variables: main_params:(loc) *main_params:in
                extra_params:(loc) *extra_params:in loss:(loc)
                *loss:out
   Plus diff mem management of: main_params:in extra_params:in
                loss:in state:in
*/
// LSTM objective (loss function)
template<unsigned NBDirsMax>
void lstm_objective_dv(int l, int c, int b,
        const double *__restrict main_params, double *__restrict main_paramsd, int main_params_size,
        const double *__restrict extra_params, double *__restrict extra_paramsd, int extra_params_size,
        double *__restrict state, const double *__restrict sequence, 
        double *__restrict loss, double *__restrict lossd) {
    int nbdirs = NBDirsMax;
    int i, t;
    double total = 0.0;
    double totald[NBDirsMax];
    int state_sz = 2 * l * b;
    double (* stated)[NBDirsMax] = (double (*)[NBDirsMax])malloc(state_sz * sizeof(double [NBDirsMax]) * NBDirsMax);
    int nd;
    int count = 0;
    const double *input = &(sequence[0]);
    double *ypred = (double *)malloc(b*sizeof(double));
    double (* ypredd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(b*sizeof(double [NBDirsMax])* NBDirsMax);
    double *ynorm = (double *)malloc(b*sizeof(double));
    double (* ynormd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(b*sizeof(double [NBDirsMax])* NBDirsMax);
    const double *ygold = NULL;
    double lse;
    double lsed[NBDirsMax];
    for (nd = 0; nd < NBDirsMax; ++nd)
        *stated[nd] = 0.0;
    for (nd = 0; nd < NBDirsMax; ++nd)
        totald[nd] = 0.0;
    for (t = 0; t <= (c-1)*b-1; t += b) {
        lstm_predict_dv(l, b, main_params, (double (*)[NBDirsMax]) main_paramsd, extra_params, (double (*)[NBDirsMax])
                        extra_paramsd, state, stated, input, ypred, ypredd, 
                        nbdirs);
        logsumexp_dv(ypred, ypredd, b, &lse, lsed, nbdirs);
        for (i = 0; i < b; ++i) {
            for (nd = 0; nd < nbdirs; ++nd)
                ynormd[i][nd] = ypredd[i][nd] - lsed[nd];
            ynorm[i] = ypred[i] - lse;
        }
        ygold = &(sequence[t + b]);
        for (i = 0; i < b; ++i) {
            for (nd = 0; nd < nbdirs; ++nd)
                totald[nd] = totald[nd] + ygold[i]*ynormd[i][nd];
            total += ygold[i]*ynorm[i];
        }
        count += b;
        input = ygold;
    }
    for (nd = 0; nd < nbdirs; ++nd)
        (* ((double (*)[NBDirsMax]) lossd))[nd] = -(totald[nd]/count);
    *loss = -total/count;
    free(ypredd);
    free(ypred);
    free(ynormd);
    free(ynorm);
}



#if 1
//! Adept
#include <adept.h>
#include <adept_arrays.h>
#include <adept_source.h>
using adept::adouble;
using adept::aVector;

namespace adeptTest {
// Sigmoid on scalar
template <typename T> T sigmoid(T x) {
  return adouble(1) / (adouble(1) + exp(-x));
}

// log(sum(exp(x), 2))
template <typename T> T logsumexp(const T *vect, int sz) {
  T sum = 0.0;
  for (int i = 0; i < sz; ++i)
    sum += exp(vect[i]);
  sum += adouble(2);
  return log(sum);
}

// LSTM OBJECTIVE

// The LSTM model
template <typename T>
void lstm_model(int hsize, T *weight, T *bias, T *hidden, T *cell, T *input) {

  T *gates = new T[4 * hsize];
  T *forget = &(gates[0]);
  T *ingate = &(gates[hsize]);
  T *outgate = &(gates[2 * hsize]);
  T *change = &(gates[3 * hsize]);

  int i;
  // caching input
  // hidden (needed)
  for (i = 0; i < hsize; i++) {
    forget[i] = sigmoid<adouble>(input[i] * weight[i] + bias[i]);
    ingate[i] =
        sigmoid<adouble>(hidden[i] * weight[hsize + i] + bias[hsize + i]);
    outgate[i] = sigmoid<adouble>(input[i] * weight[2 * hsize + i] +
                                  bias[2 * hsize + i]);
    change[i] = tanh(hidden[i] * weight[3 * hsize + i] + bias[3 * hsize + i]);
  }

  // caching cell (needed)
  for (i = 0; i < hsize; i++) {
    cell[i] = cell[i] * forget[i] + ingate[i] * change[i];
  }

  for (i = 0; i < hsize; i++) {
    hidden[i] = outgate[i] * tanh(cell[i]);
  }

  delete[] gates;
}

// Predict LSTM output given an input
template <typename T>
void lstm_predict(int l, int b, T *w, T *w2, T *s, T *x, T *x2) {
  int i;
  for (i = 0; i < b; i++) {
    x2[i] = x[i] * w2[i];
  }

  T *xp = x2;
  for (i = 0; i <= 2 * l * b - 1; i += 2 * b) {
    lstm_model(b, &(w[i * 4]), &(w[(i + b) * 4]), &(s[i]), &(s[i + b]), xp);
    xp = &(s[i]);
  }

  for (i = 0; i < b; i++) {
    x2[i] = xp[i] * w2[b + i] + w2[2 * b + i];
  }
}

// LSTM objective (loss function)
template <typename T>
void lstm_objective(int l, int c, int b, T *__restrict main_params,
                    T *__restrict extra_params, T *__restrict state,
                    T *__restrict sequence, T *__restrict loss) {
  int i, t;
  T total = 0.0;
  int count = 0;
  T *input = &(sequence[0]);
  T *ypred = new T[b];
  T *ynorm = new T[b];
  T *ygold;
  T lse;

  __builtin_assume(b > 0);
  for (t = 0; t <= (c - 1) * b - 1; t += b) {
    lstm_predict(l, b, main_params, extra_params, state, input, ypred);
    lse = logsumexp(ypred, b);
    for (i = 0; i < b; i++) {
      ynorm[i] = ypred[i] - lse;
    }

    ygold = &(sequence[t + b]);
    for (i = 0; i < b; i++) {
      total += ygold[i] * ynorm[i];
    }

    count += b;
    input = ygold;
  }

  *loss = -total / adouble(count);

  delete[] ypred;
  delete[] ynorm;
}
}; // namespace adeptTest

// Note ADBench did not have an adept impl
void adept_dlstm_objective(int l, int c, int b, const double *main_params,
                           double *main_paramsb, const double *extra_params,
                           double *extra_paramsb, double *state,
                           const double *sequence, double *loss,
                           double *lossb) {

  int main_sz = 2 * l * 4 * b;
  int extra_sz = 3 * b;
  int state_sz = 2 * l * b;
  int seq_sz = c * b;

  adept::Stack stack;

  adouble *amain = new adouble[main_sz];
  adouble *aextra = new adouble[extra_sz];
  adouble *astate = new adouble[state_sz];
  adouble *aseq = new adouble[seq_sz];

  adept::set_values(amain, main_sz, main_params);
  adept::set_values(aextra, extra_sz, extra_params);
  adept::set_values(astate, state_sz, state);
  adept::set_values(aseq, seq_sz, sequence);

  adouble aloss;

  stack.new_recording();

  adeptTest::lstm_objective(l, c, b, amain, aextra, astate, aseq, &aloss);

  adept::set_gradients(amain, main_sz, main_paramsb);
  adept::set_gradients(aextra, extra_sz, extra_paramsb);

  stack.compute_tangent_linear();

  *lossb = aloss.get_gradient();
}
#endif
