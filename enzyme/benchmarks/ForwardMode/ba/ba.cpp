// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*
 *   File "ba_b_tapenade_generated.c" is generated by Tapenade 3.14 (r7259) from
 * this file. To reproduce such a generation you can use Tapenade CLI (can be
 * downloaded from http://www-sop.inria.fr/tropics/tapenade/downloading.html)
 *
 *   After installing use the next command to generate a file:
 *
 *      tapenade -b -o ba_tapenade -head "compute_reproj_error(err)/(cam X)
 * compute_zach_weight_error(err)/(w)" ba.c
 *
 *   This will produce a file "ba_tapenade_b.c" which content will be the same
 * as the content of "ba_b_tapenade_generated.c", except one-line header.
 * Moreover a log-file "ba_tapenade_b.msg" will be produced.
 *
 *   NOTE: the code in "ba_b_tapenade_generated.c" is wrong and won't work.
 *         REPAIRED SOURCE IS STORED IN THE FILE "ba_b.c".
 *         You can either use diff tool or read "ba_b.c" header to figure out
 * what changes was performed to fix the code.
 *
 *   NOTE: you can also use Tapenade web server
 * (http://tapenade.inria.fr:8080/tapenade/index.jsp) for generating but the
 * result can be slightly different.
 */

#include "../adbench/ba.h"

extern "C" {

#include "ba.h"

/* ===================================================================== */
/*                                UTILS                                  */
/* ===================================================================== */

double sqsum(int n, double const *x) {
  int i;
  double res = 0;
  for (i = 0; i < n; i++) {
    res = res + x[i] * x[i];
  }

  return res;
}

void cross(double const *a, double const *b, double *out) {
  out[0] = a[1] * b[2] - a[2] * b[1];
  out[1] = a[2] * b[0] - a[0] * b[2];
  out[2] = a[0] * b[1] - a[1] * b[0];
}

/* ===================================================================== */
/*                               MAIN LOGIC                              */
/* ===================================================================== */

// rot: 3 rotation parameters
// pt: 3 point to be rotated
// rotatedPt: 3 rotated point
// this is an efficient evaluation (part of
// the Ceres implementation)
// easy to understand calculation in matlab:
//  theta = sqrt(sum(w. ^ 2));
//  n = w / theta;
//  n_x = au_cross_matrix(n);
//  R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rotate_point(double const *__restrict rot,
                            double const *__restrict pt,
                            double *__restrict rotatedPt) {
  int i;
  double sqtheta = sqsum(3, rot);
  if (sqtheta != 0) {
    double theta, costheta, sintheta, theta_inverse;
    double w[3], w_cross_pt[3], tmp;

    theta = sqrt(sqtheta);
    costheta = cos(theta);
    sintheta = sin(theta);
    theta_inverse = 1.0 / theta;

    for (i = 0; i < 3; i++) {
      w[i] = rot[i] * theta_inverse;
    }

    cross(w, pt, w_cross_pt);

    tmp = (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2]) * (1. - costheta);

    for (i = 0; i < 3; i++) {
      rotatedPt[i] = pt[i] * costheta + w_cross_pt[i] * sintheta + w[i] * tmp;
    }
  } else {
    double rot_cross_pt[3];
    cross(rot, pt, rot_cross_pt);

    for (i = 0; i < 3; i++) {
      rotatedPt[i] = pt[i] + rot_cross_pt[i];
    }
  }
}

void radial_distort(double const *rad_params, double *proj) {
  double rsq, L;
  rsq = sqsum(2, proj);
  L = 1. + rad_params[0] * rsq + rad_params[1] * rsq * rsq;
  proj[0] = proj[0] * L;
  proj[1] = proj[1] * L;
}

void project(double const *__restrict cam, double const *__restrict X,
             double *__restrict proj) {
  double const *C = &cam[3];
  double Xo[3], Xcam[3];

  Xo[0] = X[0] - C[0];
  Xo[1] = X[1] - C[1];
  Xo[2] = X[2] - C[2];

  rodrigues_rotate_point(&cam[0], Xo, Xcam);

  proj[0] = Xcam[0] / Xcam[2];
  proj[1] = Xcam[1] / Xcam[2];

  radial_distort(&cam[9], proj);

  proj[0] = proj[0] * cam[6] + cam[7];
  proj[1] = proj[1] * cam[6] + cam[8];
}

// cam: 11 camera in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3 point
// feats: 2 feature (x,y coordinates)
// reproj_err: 2
// projection function:
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void compute_reproj_error(double const *__restrict cam,
                          double const *__restrict X,
                          double const *__restrict w,
                          double const *__restrict feat,
                          double *__restrict err) {
  double proj[2];
  project(cam, X, proj);

  err[0] = (*w) * (proj[0] - feat[0]);
  err[1] = (*w) * (proj[1] - feat[1]);
}

void compute_zach_weight_error(double const *w, double *err) {
  *err = 1 - (*w) * (*w);
}

// n number of cameras
// m number of points
// p number of observations
// cams: 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3*m points
// obs: 2*p observations (pairs cameraIdx, pointIdx)
// feats: 2*p features (x,y coordinates corresponding to observations)
// reproj_err: 2*p errors of observations
// w_err: p weight "error" terms
void ba_objective(int n, int m, int p, double const *cams, double const *X,
                  double const *w, int const *obs, double const *feats,
                  double *reproj_err, double *w_err) {
  int i;
  for (i = 0; i < p; i++) {
    int camIdx = obs[i * 2 + 0];
    int ptIdx = obs[i * 2 + 1];
    compute_reproj_error(&cams[camIdx * BA_NCAMPARAMS], &X[ptIdx * 3], &w[i],
                         &feats[i * 2], &reproj_err[2 * i]);
  }

  for (i = 0; i < p; i++) {
    compute_zach_weight_error(&w[i], &w_err[i]);
  }
}

extern int enzyme_const;
extern int enzyme_dup;
extern int enzyme_dupnoneed;
void __enzyme_fwddiff(...) noexcept;

void dcompute_reproj_error(double const *cam, double *dcam, double const *X,
                           double *dX, double const *w, double *wb,
                           double const *feat, double *err, double *derr) {
  __enzyme_fwddiff(compute_reproj_error, enzyme_dup, cam, dcam, enzyme_dup, X,
                   dX, enzyme_dup, w, wb, enzyme_const, feat, enzyme_dupnoneed,
                   err, derr);
}

void dcompute_zach_weight_error(double const *w, double *dw, double *err,
                                double *derr) {
  __enzyme_fwddiff(compute_zach_weight_error, enzyme_dup, w, dw,
                   enzyme_dupnoneed, err, derr);
}
}

//! Tapenade
extern "C" {

/*
  Differentiation of sqsum in forward (tangent) mode:
   variations   of useful results: sqsum
   with respect to varying inputs: *x
   Plus diff mem management of: x:in

 =====================================================================
                                UTILS
 ===================================================================== */
double sqsum_d(int n, const double *x, const double *xd, double *sqsum) {
  int i;
  double res = 0;
  double resd;
  resd = 0.0;
  for (i = 0; i < n; ++i) {
    resd = resd + 2 * x[i] * xd[i];
    res = res + x[i] * x[i];
  }
  *sqsum = res;
  return resd;
}

/*
  Differentiation of cross in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *a *b
   Plus diff mem management of: out:in a:in b:in
*/
void cross_d(const double *a, const double *ad, const double *b,
             const double *bd, double *out, double *outd) {
  *outd = 0.0;
  outd[0] = b[2] * ad[1] + a[1] * bd[2] - b[1] * ad[2] - a[2] * bd[1];
  out[0] = a[1] * b[2] - a[2] * b[1];
  outd[1] = b[0] * ad[2] + a[2] * bd[0] - b[2] * ad[0] - a[0] * bd[2];
  out[1] = a[2] * b[0] - a[0] * b[2];
  outd[2] = b[1] * ad[0] + a[0] * bd[1] - b[0] * ad[1] - a[1] * bd[0];
  out[2] = a[0] * b[1] - a[1] * b[0];
}

/*
  Differentiation of rodrigues_rotate_point in forward (tangent) mode:
   variations   of useful results: *rotatedPt
   with respect to varying inputs: *rot *pt
   Plus diff mem management of: rot:in rotatedPt:in pt:in

 =====================================================================
                               MAIN LOGIC
 ===================================================================== */
// rot: 3 rotation parameters
// pt: 3 point to be rotated
// rotatedPt: 3 rotated point
// this is an efficient evaluation (part of
// the Ceres implementation)
// easy to understand calculation in matlab:
//  theta = sqrt(sum(w. ^ 2));
//  n = w / theta;
//  n_x = au_cross_matrix(n);
//  R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
void rodrigues_rotate_point_d(const double *__restrict rot,
                              const double *__restrict rotd,
                              const double *__restrict pt,
                              const double *__restrict ptd,
                              double *__restrict rotatedPt,
                              double *__restrict rotatedPtd) {
  int i;
  double sqtheta;
  double sqthetad;
  sqthetad = sqsum_d(3, rot, rotd, &sqtheta);
  if (sqtheta != 0) {
    double theta, costheta, sintheta, theta_inverse;
    double thetad, costhetad, sinthetad, theta_inversed;
    double w[3], w_cross_pt[3], tmp;
    double wd[3], w_cross_ptd[3], tmpd;
    double temp;
    int ii1;
    temp = sqrt(sqtheta);
    thetad = (sqtheta == 0.0 ? 0.0 : sqthetad / (2.0 * temp));
    theta = temp;
    costhetad = -(sin(theta) * thetad);
    costheta = cos(theta);
    sinthetad = cos(theta) * thetad;
    sintheta = sin(theta);
    theta_inversed = -(thetad / (theta * theta));
    theta_inverse = 1.0 / theta;
    for (ii1 = 0; ii1 < 3; ++ii1)
      wd[ii1] = 0.0;
    for (i = 0; i < 3; ++i) {
      wd[i] = theta_inverse * rotd[i] + rot[i] * theta_inversed;
      w[i] = rot[i] * theta_inverse;
    }
    cross_d(w, wd, pt, ptd, w_cross_pt, w_cross_ptd);
    temp = w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2];
    tmpd = (1. - costheta) * (pt[0] * wd[0] + w[0] * ptd[0] + pt[1] * wd[1] +
                              w[1] * ptd[1] + pt[2] * wd[2] + w[2] * ptd[2]) -
           temp * costhetad;
    tmp = temp * (1. - costheta);
    *rotatedPtd = 0.0;
    for (i = 0; i < 3; ++i) {
      rotatedPtd[i] = costheta * ptd[i] + pt[i] * costhetad +
                      sintheta * w_cross_ptd[i] + w_cross_pt[i] * sinthetad +
                      tmp * wd[i] + w[i] * tmpd;
      rotatedPt[i] = pt[i] * costheta + w_cross_pt[i] * sintheta + w[i] * tmp;
    }
  } else {
    double rot_cross_pt[3];
    double rot_cross_ptd[3];
    cross_d(rot, rotd, pt, ptd, rot_cross_pt, rot_cross_ptd);
    *rotatedPtd = 0.0;
    for (i = 0; i < 3; ++i) {
      rotatedPtd[i] = ptd[i] + rot_cross_ptd[i];
      rotatedPt[i] = pt[i] + rot_cross_pt[i];
    }
  }
}

/*
  Differentiation of radial_distort in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *rad_params *proj
   Plus diff mem management of: rad_params:in proj:in
*/
void radial_distort_d(const double *rad_params, const double *rad_paramsd,
                      double *proj, double *projd) {
  double rsq, L;
  double rsqd, Ld;
  rsqd = sqsum_d(2, proj, projd, &rsq);
  Ld = rsq * rad_paramsd[0] + (rad_params[0] + rad_params[1] * 2 * rsq) * rsqd +
       rsq * rsq * rad_paramsd[1];
  L = 1. + rad_params[0] * rsq + rad_params[1] * rsq * rsq;
  projd[0] = L * projd[0] + proj[0] * Ld;
  proj[0] = proj[0] * L;
  projd[1] = L * projd[1] + proj[1] * Ld;
  proj[1] = proj[1] * L;
}

/*
  Differentiation of project in forward (tangent) mode:
   variations   of useful results: *proj
   with respect to varying inputs: *cam *X
   Plus diff mem management of: cam:in X:in proj:in
*/
void project_d(const double *__restrict cam, const double *__restrict camd,
               const double *__restrict X, const double *__restrict Xd,
               double *__restrict proj, double *__restrict projd) {
  const double *C = &(cam[3]);
  const double *Cd = &(camd[3]);
  double Xo[3], Xcam[3];
  double Xod[3], Xcamd[3];
  int ii1;
  double temp;
  for (ii1 = 0; ii1 < 3; ++ii1)
    Xod[ii1] = 0.0;
  Xod[0] = Xd[0] - Cd[0];
  Xo[0] = X[0] - C[0];
  Xod[1] = Xd[1] - Cd[1];
  Xo[1] = X[1] - C[1];
  Xod[2] = Xd[2] - Cd[2];
  Xo[2] = X[2] - C[2];
  rodrigues_rotate_point_d(&(cam[0]), &(camd[0]), Xo, Xod, Xcam, Xcamd);
  *projd = 0.0;
  temp = Xcam[0] / Xcam[2];
  projd[0] = (Xcamd[0] - temp * Xcamd[2]) / Xcam[2];
  proj[0] = temp;
  temp = Xcam[1] / Xcam[2];
  projd[1] = (Xcamd[1] - temp * Xcamd[2]) / Xcam[2];
  proj[1] = temp;
  radial_distort_d(&(cam[9]), &(camd[9]), proj, projd);
  projd[0] = cam[6] * projd[0] + proj[0] * camd[6] + camd[7];
  proj[0] = proj[0] * cam[6] + cam[7];
  projd[1] = cam[6] * projd[1] + proj[1] * camd[6] + camd[8];
  proj[1] = proj[1] * cam[6] + cam[8];
}

/*
  Differentiation of compute_reproj_error in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *w *cam *X
   RW status of diff variables: err:(loc) *err:out w:(loc) *w:in
                cam:(loc) *cam:in X:(loc) *X:in
   Plus diff mem management of: err:in w:in cam:in X:in
*/
// cam: 11 camera in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3 point
// feats: 2 feature (x,y coordinates)
// reproj_err: 2
// projection function:
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
void compute_reproj_error_d(const double *__restrict cam,
                            double *__restrict camd, const double *__restrict X,
                            double *__restrict Xd, const double *__restrict w,
                            double *__restrict wd,
                            const double *__restrict feat,
                            double *__restrict err, double *__restrict errd) {
  double proj[2];
  double projd[2];
  project_d(cam, camd, X, Xd, proj, projd);
  *errd = 0.0;
  errd[0] = (proj[0] - feat[0]) * (*wd) + (*w) * projd[0];
  err[0] = (*w) * (proj[0] - feat[0]);
  errd[1] = (proj[1] - feat[1]) * (*wd) + (*w) * projd[1];
  err[1] = (*w) * (proj[1] - feat[1]);
}

/*
  Differentiation of compute_zach_weight_error in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *w
   RW status of diff variables: err:(loc) *err:out w:(loc) *w:in
   Plus diff mem management of: err:in w:in
*/
void compute_zach_weight_error_d(const double *w, double *wd, double *err,
                                 double *errd) {
  *errd = -(2 * (*w) * (*wd));
  *err = 1 - (*w) * (*w);
}
}

#include <adept.h>
#include <adept_arrays.h>
#include <adept_source.h>
using adept::adouble;
using adept::aVector;

namespace adeptTest {

template <typename T> void cross(const T *const a, const T *const b, T *out) {
  out[0] = a[1] * b[2] - a[2] * b[1];
  out[1] = a[2] * b[0] - a[0] * b[2];
  out[2] = a[0] * b[1] - a[1] * b[0];
}

////////////////////////////////////////////////////////////
//////////////////// Declarations //////////////////////////
////////////////////////////////////////////////////////////

// cam: 11 camera in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3 point
// feats: 2 feature (x,y coordinates)
// reproj_err: 2
// projection function:
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
template <typename T>
void computeReprojError(const T *const cam, const T *const X, const T *const w,
                        const double *const feat, T *err);

// w: 1
// w_err: 1
template <typename T> void computeZachWeightError(const T *const w, T *err);

// n number of cameras
// m number of points
// p number of observations
// cams: 11*n cameras in format [r1 r2 r3 C1 C2 C3 f u0 v0 k1 k2]
//            r1, r2, r3 are angle - axis rotation parameters(Rodrigues)
//            [C1 C2 C3]' is the camera center
//            f is the focal length in pixels
//            [u0 v0]' is the principal point
//            k1, k2 are radial distortion parameters
// X: 3*m points
// obs: 2*p observations (pairs cameraIdx, pointIdx)
// feats: 2*p features (x,y coordinates corresponding to observations)
// reproj_err: 2*p errors of observations
// w_err: p weight "error" terms
// projection function:
// Xcam = R * (X - C)
// distorted = radial_distort(projective2euclidean(Xcam), radial_parameters)
// proj = distorted * f + principal_point
// err = sqsum(proj - measurement)
template <typename T>
void ba_objective(int n, int m, int p, const T *const cams, const T *const X,
                  const T *const w, const int *const obs,
                  const double *const feats, T *reproj_err, T *w_err);

// rot: 3 rotation parameters
// pt: 3 point to be rotated
// rotatedPt: 3 rotated point
// this is an efficient evaluation (part of
// the Ceres implementation)
// easy to understand calculation in matlab:
//  theta = sqrt(sum(w. ^ 2));
//  n = w / theta;
//  n_x = au_cross_matrix(n);
//  R = eye(3) + n_x*sin(theta) + n_x*n_x*(1 - cos(theta));
template <typename T>
void rodrigues_rotate_point(const T *const rot, const T *const pt,
                            T *rotatedPt);

////////////////////////////////////////////////////////////
//////////////////// Definitions ///////////////////////////
////////////////////////////////////////////////////////////

template <typename T> T sqsum(int n, const T *const x) {
  T res = 0;
  for (int i = 0; i < n; i++)
    res = res + x[i] * x[i];
  return res;
}

template <typename T>
void rodrigues_rotate_point(const T *const rot, const T *const pt,
                            T *rotatedPt) {
  T sqtheta = sqsum(3, rot);
  if (sqtheta != 0) {
    T theta, costheta, sintheta, theta_inverse, w[3], w_cross_pt[3], tmp;

    theta = sqrt(sqtheta);
    costheta = cos(theta);
    sintheta = sin(theta);
    theta_inverse = 1.0 / theta;

    for (int i = 0; i < 3; i++)
      w[i] = rot[i] * theta_inverse;

    cross(w, pt, w_cross_pt);

    tmp = (w[0] * pt[0] + w[1] * pt[1] + w[2] * pt[2]) * (1. - costheta);

    for (int i = 0; i < 3; i++)
      rotatedPt[i] = pt[i] * costheta + w_cross_pt[i] * sintheta + w[i] * tmp;
  } else {
    T rot_cross_pt[3];
    cross(rot, pt, rot_cross_pt);

    for (int i = 0; i < 3; i++)
      rotatedPt[i] = pt[i] + rot_cross_pt[i];
  }
}

template <typename T> void radial_distort(const T *const rad_params, T *proj) {
  T rsq, L;
  rsq = sqsum(2, proj);
  L = 1. + rad_params[0] * rsq + rad_params[1] * rsq * rsq;
  proj[0] = proj[0] * L;
  proj[1] = proj[1] * L;
}

template <typename T>
void project(const T *const cam, const T *const X, T *proj) {
  const T *const C = &cam[3];
  T Xo[3], Xcam[3];

  Xo[0] = X[0] - C[0];
  Xo[1] = X[1] - C[1];
  Xo[2] = X[2] - C[2];

  rodrigues_rotate_point(&cam[0], Xo, Xcam);

  proj[0] = Xcam[0] / Xcam[2];
  proj[1] = Xcam[1] / Xcam[2];

  radial_distort(&cam[9], proj);

  proj[0] = proj[0] * cam[6] + cam[7];
  proj[1] = proj[1] * cam[6] + cam[8];
}

template <typename T>
void computeReprojError(const T *const cam, const T *const X, const T *const w,
                        const double *const feat, T *err) {
  T proj[2];
  project(cam, X, proj);

  err[0] = (*w) * (proj[0] - feat[0]);
  err[1] = (*w) * (proj[1] - feat[1]);
}

template <typename T> void computeZachWeightError(const T *const w, T *err) {
  *err = 1 - (*w) * (*w);
}

template <typename T>
void ba_objective(int n, int m, int p, const T *const cams, const T *const X,
                  const T *const w, const int *const obs,
                  const double *const feats, T *reproj_err, T *w_err) {
  for (int i = 0; i < p; i++) {
    int camIdx = obs[i * 2 + 0];
    int ptIdx = obs[i * 2 + 1];
    computeReprojError(&cams[camIdx * BA_NCAMPARAMS], &X[ptIdx * 3], &w[i],
                       &feats[i * 2], &reproj_err[2 * i]);
  }

  for (int i = 0; i < p; i++) {
    computeZachWeightError(&w[i], &w_err[i]);
  }
}
}; // namespace adeptTest

void adept_compute_reproj_error(double const *cam, double *dcam,
                                double const *X, double *dX, double const *w,
                                double *wb, double const *feat, double *err,
                                double *derr) {

  adept::Stack stack;

  adouble acam[BA_NCAMPARAMS];
  adept::set_values(acam, BA_NCAMPARAMS, cam);

  adouble aX[3];
  adept::set_values(aX, 3, X);

  adouble aw;
  aw.set_value(*w);

  adouble areproj_err[2];

  stack.new_recording();

  adeptTest::computeReprojError(acam, aX, &aw, feat, areproj_err);

  adept::set_gradients(acam, BA_NCAMPARAMS, dcam);

  adept::set_gradients(aX, 3, dX);

  aw.set_gradient(*wb);

  stack.compute_tangent_linear();

  adept::get_gradients(areproj_err, 2, derr);
}

void adept_compute_zach_weight_error(double const *w, double *dw, double *err,
                                     double *derr) {
  adept::Stack stack;

  adouble aw;
  aw.set_value(*w);

  adouble aw_err;

  stack.new_recording();
  adeptTest::computeZachWeightError(&aw, &aw_err);
  aw.set_gradient(1.0);

  stack.compute_tangent_linear();

  *derr = aw_err.get_gradient();
}
