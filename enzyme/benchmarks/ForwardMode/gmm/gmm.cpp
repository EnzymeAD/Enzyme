// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*
 *   File "gmm_b_tapenade_generated.c" is generated by Tapenade 3.14 (r7259)
 * from this file. To reproduce such a generation you can use Tapenade CLI (can
 * be downloaded from http://www-sop.inria.fr/tropics/tapenade/downloading.html)
 *
 *   Firstly, add a type declaration of Wishart to the content of this file
 * (Tapenade can't process a file with unknown types). You can both take this
 * declaration from the file "<repo root>/src/cpp/shared/defs.h" or copypaste
 * the following lines removing asterisks:
 *
 *   typedef struct
 *   {
 *       double gamma;
 *       int m;
 *   } Wishart;
 *
 *   After Tapenade CLI installing use the next command to generate a file:
 *
 *      tapenade -b -o gmm_tapenade -head "gmm_objective(err)/(alphas means
 * icf)" gmm.c
 *
 *   This will produce a file "gmm_tapenade_b.c" which content will be the same
 * as the content of "gmm_b_tapenade_generated.c", except one-line header and a
 * Wishart typedef (which should be removed). Moreover a log-file
 * "gmm_tapenade_b.msg" will be produced.
 *
 *   NOTE: the code in "gmm_b_tapenade_generated.c" is wrong and won't work.
 *         REPAIRED SOURCE IS STORED IN THE FILE "gmm_b.c".
 *         You can either use diff tool or read "gmm_b.c" header to figure out
 * what changes was performed to fix the code.
 *
 *   NOTE: you can also use Tapenade web server
 * (http://tapenade.inria.fr:8080/tapenade/index.jsp) for generating but result
 * can be slightly different.
 */
#include "../adbench/gmm.h"
extern "C" {
#include "gmm.h"

/* ==================================================================== */
/*                                UTILS                                 */
/* ==================================================================== */

// This throws error on n<1
double arr_max(int n, double const *x) {
  int i;
  double m = x[0];
  for (i = 1; i < n; i++) {
    if (m < x[i]) {
      m = x[i];
    }
  }

  return m;
}

// sum of component squares
double sqnorm(int n, double const *x) {
  int i;
  double res = x[0] * x[0];
  for (i = 1; i < n; i++) {
    res = res + x[i] * x[i];
  }

  return res;
}

// out = a - b
void subtract(int d, double const *x, double const *y, double *out) {
  int id;
  for (id = 0; id < d; id++) {
    out[id] = x[id] - y[id];
  }
}

double log_sum_exp(int n, double const *x) {
  int i;
  double mx = arr_max(n, x);
  double semx = 0.0;

  for (i = 0; i < n; i++) {
    semx = semx + exp(x[i] - mx);
  }

  return log(semx) + mx;
}

__attribute__((const)) double log_gamma_distrib(double a, double p) {
  int j;
  double out = 0.25 * p * (p - 1) * log(PI);

  for (j = 1; j <= p; j++) {
    out = out + lgamma(a + 0.5 * (1 - j));
  }

  return out;
}

/* ======================================================================== */
/*                                MAIN LOGIC                                */
/* ======================================================================== */

double log_wishart_prior(int p, int k, Wishart wishart, double const *sum_qs,
                         double const *Qdiags, double const *icf) {
  int ik;
  int n = p + wishart.m + 1;
  int icf_sz = p * (p + 1) / 2;

  double C = n * p * (log(wishart.gamma) - 0.5 * log(2)) -
             log_gamma_distrib(0.5 * n, p);

  double out = 0;
  for (ik = 0; ik < k; ik++) {
    double frobenius =
        sqnorm(p, &Qdiags[ik * p]) + sqnorm(icf_sz - p, &icf[ik * icf_sz + p]);
    out = out + 0.5 * wishart.gamma * wishart.gamma * (frobenius)-wishart.m *
                    sum_qs[ik];
  }

  return out - k * C;
}

void preprocess_qs(int d, int k, double const *icf, double *sum_qs,
                   double *Qdiags) {
  int ik, id;
  int icf_sz = d * (d + 1) / 2;
  for (ik = 0; ik < k; ik++) {
    sum_qs[ik] = 0.;
    for (id = 0; id < d; id++) {
      double q = icf[ik * icf_sz + id];
      sum_qs[ik] = sum_qs[ik] + q;
      Qdiags[ik * d + id] = exp(q);
    }
  }
}

void Qtimesx(int d, double const *Qdiag,
             double const *ltri, // strictly lower triangular part
             double const *x, double *out) {
  int i, j;
  for (i = 0; i < d; i++) {
    out[i] = Qdiag[i] * x[i];
  }

  // caching lparams as scev doesn't replicate index calculation
  //  todo note changing to strengthened form
  // int Lparamsidx = 0;
  for (i = 0; i < d; i++) {
    int Lparamsidx = i * (2 * d - i - 1) / 2;
    for (j = i + 1; j < d; j++) {
      // and this x
      out[j] = out[j] + ltri[Lparamsidx] * x[i];
      Lparamsidx++;
    }
  }
}

void gmm_objective(int d, int k, int n, double const *__restrict alphas,
                   double const *__restrict means, double const *__restrict icf,
                   double const *__restrict x, Wishart wishart,
                   double *__restrict err) {
#define int int64_t
  int ix, ik;
  const double CONSTANT = -n * d * 0.5 * log(2 * PI);
  int icf_sz = d * (d + 1) / 2;

  double *Qdiags = (double *)malloc(d * k * sizeof(double));
  double *sum_qs = (double *)malloc(k * sizeof(double));
  double *xcentered = (double *)malloc(d * sizeof(double));
  double *Qxcentered = (double *)malloc(d * sizeof(double));
  double *main_term = (double *)malloc(k * sizeof(double));

  preprocess_qs(d, k, icf, &sum_qs[0], &Qdiags[0]);

  double slse = 0.;
  for (ix = 0; ix < n; ix++) {
    for (ik = 0; ik < k; ik++) {
      subtract(d, &x[ix * d], &means[ik * d], &xcentered[0]);
      Qtimesx(d, &Qdiags[ik * d], &icf[ik * icf_sz + d], &xcentered[0],
              &Qxcentered[0]);
      // two caches for qxcentered at idx 0 and at arbitrary index
      main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5 * sqnorm(d, &Qxcentered[0]);
    }

    // storing cmp for max of main_term
    // 2 x (0 and arbitrary) storing sub to exp
    // storing sum for use in log
    slse = slse + log_sum_exp(k, &main_term[0]);
  }

  // storing cmp of alphas
  double lse_alphas = log_sum_exp(k, alphas);

  *err = CONSTANT + slse - n * lse_alphas +
         log_wishart_prior(d, k, wishart, &sum_qs[0], &Qdiags[0], icf);

  free(Qdiags);
  free(sum_qs);
  free(xcentered);
  free(Qxcentered);
  free(main_term);
#undef int
}

extern int enzyme_const;
extern int enzyme_dup;
extern int enzyme_dupv;
extern int enzyme_dupnoneed;
extern int enzyme_dupnoneedv;
extern int enzyme_width;

void __enzyme_fwddiff(...) noexcept;
void __enzyme_fwddiff_vec(...) noexcept;


// *      tapenade -b -o gmm_tapenade -head "gmm_objective(err)/(alphas means
// icf)" gmm.c
void dgmm_objective(int d, int k, int n, 
                    const double *__restrict alphas, double *__restrict alphasb,
                    const double *__restrict means, double *__restrict meansb, 
                    const double *__restrict icf, double *__restrict icfb, 
                    const double *__restrict x, 
                    Wishart wishart, 
                    double *__restrict err, double *__restrict errb) {
  __enzyme_fwddiff(gmm_objective, 
                    enzyme_const, d, 
                    enzyme_const, k,
                    enzyme_const, n, 
                    enzyme_dup, alphas, alphasb, 
                    enzyme_dup, means, meansb, 
                    enzyme_dup, icf, icfb, 
                    enzyme_const, x,
                    enzyme_const, wishart,
                    enzyme_dupnoneed, err, errb);
}

}

template <unsigned vector_width>
void dgmm_objective_vec(int d, int k, int n,
                    const double *__restrict alphas, double *__restrict alphasb, int alphas_size,
                    const double *__restrict means, double *__restrict meansb, int means_size,
                    const double *__restrict icf, double *__restrict icfb, int icf_size,
                    const double *__restrict x, 
                    Wishart wishart, 
                    double *__restrict err, double *__restrict errb) {

  __enzyme_fwddiff_vec(gmm_objective,
                    enzyme_width, vector_width,
                    enzyme_const, d, 
                    enzyme_const, k,
                    enzyme_const, n, 
                    enzyme_dupv, sizeof(double) * alphas_size, alphas, alphasb, 
                    enzyme_dupv, sizeof(double) * means_size, means, meansb, 
                    enzyme_dupv, sizeof(double) * icf_size, icf, icfb, 
                    enzyme_const, x,
                    enzyme_const, wishart,
                    enzyme_dupnoneedv, sizeof(double) * 1, err, errb);
}

// ! Tapenade
extern "C" {

/*
  Differentiation of arr_max in forward (tangent) mode:
   variations   of useful results: arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in

 ====================================================================
                                UTILS
 ==================================================================== */
// This throws error on n<1
double arr_max_d(int n, const double *x, const double *xd, double *arr_max) {
  int i;
  double m = x[0];
  double md = xd[0];
  for (i = 1; i < n; ++i)
    if (m < x[i]) {
      md = xd[i];
      m = x[i];
    }
  *arr_max = m;
  return md;
}

/*
  Differentiation of sqnorm in forward (tangent) mode:
   variations   of useful results: sqnorm
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// sum of component squares
double sqnorm_d(int n, const double *x, const double *xd, double *sqnorm) {
  int i;
  double res = x[0] * x[0];
  double resd = 2 * x[0] * xd[0];
  for (i = 1; i < n; ++i) {
    resd = resd + 2 * x[i] * xd[i];
    res = res + x[i] * x[i];
  }
  *sqnorm = res;
  return resd;
}

/*
  Differentiation of subtract in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *y
   Plus diff mem management of: out:in y:in
*/
// out = a - b
void subtract_d(int d, const double *x, const double *y, const double *yd,
                double *out, double *outd) {
  int id;
  for (id = 0; id < d; ++id) {
    outd[id] = -yd[id];
    out[id] = x[id] - y[id];
  }
}

/*
  Differentiation of log_sum_exp in forward (tangent) mode:
   variations   of useful results: log_sum_exp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
double log_sum_exp_d(int n, const double *x, const double *xd,
                     double *log_sum_exp) {
  int i;
  double mx;
  double mxd;
  mxd = arr_max_d(n, x, xd, &mx);
  double semx = 0.0;
  double semxd;
  semxd = 0.0;
  for (i = 0; i < n; ++i) {
    semxd = semxd + exp(x[i] - mx) * (xd[i] - mxd);
    semx = semx + exp(x[i] - mx);
  }
  *log_sum_exp = log(semx) + mx;
  return semxd / semx + mxd;
}

double log_gamma_distrib_c(double a, double p) {
  int j;
  double out = 0.25 * p * (p - 1) * log(PI);
  double result1;
  for (j = 1; j < p + 1; ++j) {
    result1 = lgamma(a + 0.5 * (1 - j));
    out = out + result1;
  }
  return out;
}

/*
  Differentiation of log_wishart_prior in forward (tangent) mode:
   variations   of useful results: log_wishart_prior
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in

 ========================================================================
                                MAIN LOGIC
 ======================================================================== */
double log_wishart_prior_d(int p, int k, Wishart wishart, const double *sum_qs,
                           const double *sum_qsd, const double *Qdiags,
                           const double *Qdiagsd, const double *icf,
                           const double *icfd, double *log_wishart_prior) {
  int ik;
  int n = p + wishart.m + 1;
  int icf_sz = p * (p + 1) / 2;
  double C;
  double result1;
  result1 = log_gamma_distrib_c(0.5 * n, p);
  C = n * p * (log(wishart.gamma) - 0.5 * log(2)) - result1;
  double out = 0;
  double outd;
  outd = 0.0;
  for (ik = 0; ik < k; ++ik) {
    double frobenius;
    double frobeniusd;
    double result1;
    double result1d;
    double result2;
    double result2d;
    result1d = sqnorm_d(p, &(Qdiags[ik * p]), &(Qdiagsd[ik * p]), &result1);
    result2d = sqnorm_d(icf_sz - p, &(icf[ik * icf_sz + p]),
                        &(icfd[ik * icf_sz + p]), &result2);
    frobeniusd = result1d + result2d;
    frobenius = result1 + result2;
    outd = outd + wishart.gamma * wishart.gamma * 0.5 * frobeniusd -
           wishart.m * sum_qsd[ik];
    out = out + 0.5 * wishart.gamma * wishart.gamma * frobenius -
          wishart.m * sum_qs[ik];
  }
  *log_wishart_prior = out - k * C;
  return outd;
}

/*
  Differentiation of preprocess_qs in forward (tangent) mode:
   variations   of useful results: *Qdiags *sum_qs
   with respect to varying inputs: *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in
*/
void preprocess_qs_d(int d, int k, const double *icf, const double *icfd,
                     double *sum_qs, double *sum_qsd, double *Qdiags,
                     double *Qdiagsd) {
  int ik, id;
  int icf_sz = d * (d + 1) / 2;
  *Qdiagsd = 0.0;
  *sum_qsd = 0.0;
  for (ik = 0; ik < k; ++ik) {
    sum_qsd[ik] = 0.0;
    sum_qs[ik] = 0.;
    for (id = 0; id < d; ++id) {
      double q = icf[ik * icf_sz + id];
      double qd = icfd[ik * icf_sz + id];
      sum_qsd[ik] = sum_qsd[ik] + qd;
      sum_qs[ik] = sum_qs[ik] + q;
      Qdiagsd[ik * d + id] = exp(q) * qd;
      Qdiags[ik * d + id] = exp(q);
    }
  }
}

/*
  Differentiation of Qtimesx in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *Qdiag *x *ltri
   Plus diff mem management of: out:in Qdiag:in x:in ltri:in
*/
void Qtimesx_d(int d, const double *Qdiag, const double *Qdiagd,
               const double *ltri, const double *ltrid, const double *x,
               const double *xd, double *out, double *outd) {
  // strictly lower triangular part
  int i, j;
  for (i = 0; i < d; ++i) {
    outd[i] = x[i] * Qdiagd[i] + Qdiag[i] * xd[i];
    out[i] = Qdiag[i] * x[i];
  }
  // caching lparams as scev doesn't replicate index calculation
  //  todo note changing to strengthened form
  // int Lparamsidx = 0;
  for (i = 0; i < d; ++i) {
    int Lparamsidx = i * (2 * d - i - 1) / 2;
    for (j = i + 1; j < d; ++j) {
      // and this x
      outd[j] = outd[j] + x[i] * ltrid[Lparamsidx] + ltri[Lparamsidx] * xd[i];
      out[j] = out[j] + ltri[Lparamsidx] * x[i];
      Lparamsidx++;
    }
  }
}

/*
  Differentiation of gmm_objective in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *means *icf *alphas
   RW status of diff variables: err:(loc) *err:out means:(loc)
                *means:in icf:(loc) *icf:in alphas:(loc) *alphas:in
   Plus diff mem management of: err:in means:in icf:in alphas:in
*/
void gmm_objective_d(int d, int k, int n, const double *__restrict alphas,
                     double *__restrict alphasd, const double *__restrict means,
                     double *__restrict meansd, const double *__restrict icf,
                     double *__restrict icfd, const double *__restrict x,
                     Wishart wishart, double *__restrict err,
                     double *__restrict errd) {
  int ix, ik;
  const double CONSTANT = -n * d * 0.5 * log(2 * PI);
  int icf_sz = d * (d + 1) / 2;
  double *Qdiags;
  double *Qdiagsd;
  double result1;
  double result1d;
  Qdiagsd = (double *)malloc(d * k * sizeof(double));
  Qdiags = (double *)malloc(d * k * sizeof(double));
  double *sum_qs;
  double *sum_qsd;
  sum_qsd = (double *)malloc(k * sizeof(double));
  sum_qs = (double *)malloc(k * sizeof(double));
  double *xcentered;
  double *xcenteredd;
  xcenteredd = (double *)malloc(d * sizeof(double));
  xcentered = (double *)malloc(d * sizeof(double));
  double *Qxcentered;
  double *Qxcenteredd;
  Qxcenteredd = (double *)malloc(d * sizeof(double));
  Qxcentered = (double *)malloc(d * sizeof(double));
  double *main_term;
  double *main_termd;
  main_termd = (double *)malloc(k * sizeof(double));
  main_term = (double *)malloc(k * sizeof(double));
  preprocess_qs_d(d, k, icf, icfd, &(sum_qs[0]), &(sum_qsd[0]), &(Qdiags[0]),
                  &(Qdiagsd[0]));
  double slse = 0.;
  double slsed;
  slsed = 0.0;
  for (ix = 0; ix < n; ++ix) {
    for (ik = 0; ik < k; ++ik) {
      subtract_d(d, &(x[ix * d]), &(means[ik * d]), &(meansd[ik * d]),
                 &(xcentered[0]), &(xcenteredd[0]));
      Qtimesx_d(d, &(Qdiags[ik * d]), &(Qdiagsd[ik * d]),
                &(icf[ik * icf_sz + d]), &(icfd[ik * icf_sz + d]),
                &(xcentered[0]), &(xcenteredd[0]), &(Qxcentered[0]),
                &(Qxcenteredd[0]));
      // two caches for qxcentered at idx 0 and at arbitrary index
      result1d = sqnorm_d(d, &(Qxcentered[0]), &(Qxcenteredd[0]), &result1);
      main_termd[ik] = alphasd[ik] + sum_qsd[ik] - 0.5 * result1d;
      main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5 * result1;
    }
    // storing cmp for max of main_term
    // 2 x (0 and arbitrary) storing sub to exp
    // storing sum for use in log
    result1d = log_sum_exp_d(k, &(main_term[0]), &(main_termd[0]), &result1);
    slsed = slsed + result1d;
    slse = slse + result1;
  }
  // storing cmp of alphas
  double lse_alphas;
  double lse_alphasd;
  lse_alphasd = log_sum_exp_d(k, alphas, alphasd, &lse_alphas);
  result1d =
      log_wishart_prior_d(d, k, wishart, &(sum_qs[0]), &(sum_qsd[0]),
                          &(Qdiags[0]), &(Qdiagsd[0]), icf, icfd, &result1);
  *errd = slsed - n * lse_alphasd + result1d;
  *err = CONSTANT + slse - n * lse_alphas + result1;
  free(Qdiagsd);
  free(Qdiags);
  free(sum_qsd);
  free(sum_qs);
  free(xcenteredd);
  free(xcentered);
  free(Qxcenteredd);
  free(Qxcentered);
  free(main_termd);
  free(main_term);
}
}

// Tapenade vector

/*
  Differentiation of arr_max in forward (tangent) mode:
   variations   of useful results: arr_max
   with respect to varying inputs: *x
   Plus diff mem management of: x:in

 ==================================================================== 
                                UTILS                                 
 ==================================================================== */
// This throws error on n<1
template <unsigned NBDirsMax>
void arr_max_dv(int n, const double *x, const double (*xd)[NBDirsMax], double 
        *arr_max, double arr_maxd[NBDirsMax], int nbdirs) {
    int i;
    double m;
    double md[NBDirsMax];
    int nd;
    for (nd = 0; nd < nbdirs; ++nd)
        md[nd] = xd[0][nd];
    m = x[0];
    for (i = 1; i < n; ++i)
        if (m < x[i]) {
            for (nd = 0; nd < nbdirs; ++nd)
                md[nd] = xd[i][nd];
            m = x[i];
        }
    *arr_max = m;
    for (nd = 0; nd < nbdirs; ++nd)
        arr_maxd[nd] = md[nd];
}

/*
  Differentiation of sqnorm in forward (tangent) mode:
   variations   of useful results: sqnorm
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
// sum of component squares
template <unsigned NBDirsMax>
void sqnorm_dv(int n, const double *x, const double (*xd)[NBDirsMax], double *
        sqnorm, double sqnormd[NBDirsMax], int nbdirs) {
    int i;
    double res;
    double resd[NBDirsMax];
    int nd;
    for (nd = 0; nd < nbdirs; ++nd)
        resd[nd] = 2*x[0]*xd[0][nd];
    res = x[0]*x[0];
    for (i = 1; i < n; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            resd[nd] = resd[nd] + 2*x[i]*xd[i][nd];
        res = res + x[i]*x[i];
    }
    *sqnorm = res;
    for (nd = 0; nd < nbdirs; ++nd)
        sqnormd[nd] = resd[nd];
}

/*
  Differentiation of subtract in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *y
   Plus diff mem management of: out:in y:in
*/
// out = a - b
template <unsigned NBDirsMax>
void subtract_dv(int d, const double *x, const double *y, const double (*yd)[
        NBDirsMax], double *out, double (*outd)[NBDirsMax], int nbdirs) {
    int id;
    int nd;
    for (id = 0; id < d; ++id) {
        for (nd = 0; nd < nbdirs; ++nd)
            outd[id][nd] = -yd[id][nd];
        out[id] = x[id] - y[id];
    }
}

/*
  Differentiation of log_sum_exp in forward (tangent) mode:
   variations   of useful results: log_sum_exp
   with respect to varying inputs: *x
   Plus diff mem management of: x:in
*/
template <unsigned NBDirsMax>
void log_sum_exp_dv(int n, const double *x, const double (*xd)[NBDirsMax], 
        double *log_sum_exp, double log_sum_expd[NBDirsMax], int nbdirs) {
    int i;
    double mx;
    double mxd[NBDirsMax];
    double arg1;
    double arg1d[NBDirsMax];
    int nd;
    arr_max_dv(n, x, xd, &mx, mxd, nbdirs);
    double semx = 0.0;
    double semxd[NBDirsMax];
     
    for (nd = 0; nd < NBDirsMax; ++nd)
        semxd[nd] = 0.0;
    for (i = 0; i < n; ++i) {
        arg1 = x[i] - mx;
        for (nd = 0; nd < nbdirs; ++nd) {
            arg1d[nd] = xd[i][nd] - mxd[nd];
            semxd[nd] = semxd[nd] + exp(arg1)*arg1d[nd];
        }
        semx = semx + exp(arg1);
    }
    *log_sum_exp = log(semx) + mx;
    for (nd = 0; nd < nbdirs; ++nd)
        log_sum_expd[nd] = semxd[nd]/semx + mxd[nd];
}

/*
  Differentiation of log_wishart_prior in forward (tangent) mode:
   variations   of useful results: log_wishart_prior
   with respect to varying inputs: *Qdiags *sum_qs *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in

 ======================================================================== 
                                MAIN LOGIC                                
 ======================================================================== */
template <unsigned NBDirsMax>
void log_wishart_prior_dv(int p, int k, Wishart wishart, const double *sum_qs,
        const double (*sum_qsd)[NBDirsMax], const double *Qdiags, const double
        (*Qdiagsd)[NBDirsMax], const double *icf, const double (*icfd)[
        NBDirsMax], double *log_wishart_prior, double log_wishart_priord[
        NBDirsMax], int nbdirs) {
    int ik;
    int n = p + wishart.m + 1;
    float arg1 = 0.5*n;
    double result1 = log_gamma_distrib_c(arg1, p);
    int nd;
    int icf_sz = p*(p+1)/2;
    double C = n*p*(log(wishart.gamma)-0.5*log(2)) - result1;
    double out = 0;
    double outd[NBDirsMax];
    for (nd = 0; nd < NBDirsMax; ++nd)
        outd[nd] = 0.0;
    for (ik = 0; ik < k; ++ik) {
        double result1;
        double result1d[NBDirsMax];
        int arg1;
        double result2;
        double result2d[NBDirsMax];
        sqnorm_dv(p, &(Qdiags[ik*p]), &(Qdiagsd[ik*p]), &result1, result1d, 
                  nbdirs);
        arg1 = icf_sz - p;
        sqnorm_dv(arg1, &(icf[ik*icf_sz + p]), &(icfd[ik*icf_sz + p]), &
                  result2, result2d, nbdirs);
        double frobenius;
        double frobeniusd[NBDirsMax];
        for (nd = 0; nd < nbdirs; ++nd) {
            frobeniusd[nd] = result1d[nd] + result2d[nd];
            outd[nd] = outd[nd] + wishart.gamma*wishart.gamma*0.5*frobeniusd[
                nd] - wishart.m*sum_qsd[ik][nd];
        }
        frobenius = result1 + result2;
        out = out + 0.5*wishart.gamma*wishart.gamma*frobenius - wishart.m*
            sum_qs[ik];
    }
    *log_wishart_prior = out - k*C;
    for (nd = 0; nd < nbdirs; ++nd)
        log_wishart_priord[nd] = outd[nd];
}

/*
  Differentiation of preprocess_qs in forward (tangent) mode:
   variations   of useful results: *Qdiags *sum_qs
   with respect to varying inputs: *icf
   Plus diff mem management of: Qdiags:in sum_qs:in icf:in
*/
template <unsigned NBDirsMax>
void preprocess_qs_dv(int d, int k, const double *icf, const double (*icfd)[
        NBDirsMax], double *sum_qs, double (*sum_qsd)[NBDirsMax], double *
        Qdiags, double (*Qdiagsd)[NBDirsMax], int nbdirs) {
    int ik, id;
    int icf_sz = d*(d+1)/2;
    int nd;
    
    for (nd = 0; nd < NBDirsMax; ++nd)
        *Qdiagsd[nd] = 0.0;
    for (nd = 0; nd < NBDirsMax; ++nd)
        *sum_qsd[nd] = 0.0;
    for (ik = 0; ik < k; ++ik) {
        for (nd = 0; nd < nbdirs; ++nd)
            sum_qsd[ik][nd] = 0.0;
        sum_qs[ik] = 0.;
        for (id = 0; id < d; ++id) {
            double q;
            double qd[NBDirsMax];
            q = icf[ik*icf_sz + id];
            for (nd = 0; nd < nbdirs; ++nd) {
                qd[nd] = icfd[ik*icf_sz + id][nd];
                sum_qsd[ik][nd] = sum_qsd[ik][nd] + qd[nd];
                Qdiagsd[ik*d + id][nd] = exp(q)*qd[nd];
            }
            sum_qs[ik] = sum_qs[ik] + q;
            Qdiags[ik*d + id] = exp(q);
        }
    }
}

/*
  Differentiation of Qtimesx in forward (tangent) mode:
   variations   of useful results: *out
   with respect to varying inputs: *out *Qdiag *x *ltri
   Plus diff mem management of: out:in Qdiag:in x:in ltri:in
*/
template <unsigned NBDirsMax>
void Qtimesx_dv(int d, const double *Qdiag, const double (*Qdiagd)[NBDirsMax],
        const double *ltri, const double (*ltrid)[NBDirsMax], const double *x,
        const double (*xd)[NBDirsMax], double *out, double (*outd)[NBDirsMax],
        int nbdirs) {
    // strictly lower triangular part
    int i, j;
    int nd;
    for (i = 0; i < d; ++i) {
        for (nd = 0; nd < nbdirs; ++nd)
            outd[i][nd] = x[i]*Qdiagd[i][nd] + Qdiag[i]*xd[i][nd];
        out[i] = Qdiag[i]*x[i];
    }
    // caching lparams as scev doesn't replicate index calculation
    //  todo note changing to strengthened form
    // int Lparamsidx = 0;
    for (i = 0; i < d; ++i) {
        int Lparamsidx;
        Lparamsidx = i*(2*d-i-1)/2;
        for (j = i+1; j < d; ++j) {
            // and this x
            for (nd = 0; nd < nbdirs; ++nd)
                outd[j][nd] = outd[j][nd] + x[i]*ltrid[Lparamsidx][nd] + ltri[
                    Lparamsidx]*xd[i][nd];
            out[j] = out[j] + ltri[Lparamsidx]*x[i];
            Lparamsidx++;
        }
    }
}

/*
  Differentiation of gmm_objective in forward (tangent) mode:
   variations   of useful results: *err
   with respect to varying inputs: *means *icf *alphas
   RW status of diff variables: err:(loc) *err:out means:(loc)
                *means:in icf:(loc) *icf:in alphas:(loc) *alphas:in
   Plus diff mem management of: err:in means:in icf:in alphas:in
*/
template <unsigned NBDirsMax>
void gmm_objective_dv(int d, int k, int n,
                    const double *__restrict alphas, double *__restrict alphasd, int alphas_size,
                    const double *__restrict means, double *__restrict meansd, int means_size,
                    const double *__restrict icf, double *__restrict icfd, int icf_size,
                    const double *__restrict x,
                    Wishart wishart, 
                    double *__restrict err, double *__restrict errd) {
    int nbdirs = NBDirsMax;
    long int ix, ik;
    const double CONSTANT = -n*d*0.5*log(2*PI);
    long int icf_sz = d*(d+1)/2;
    double result1;
    double result1d[NBDirsMax];
    int nd;
    
    double *Qdiags = (double *)malloc(d*k*sizeof(double));
    double (* Qdiagsd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(d*k*sizeof(double [NBDirsMax])* NBDirsMax);
    double *sum_qs = (double *)malloc(k*sizeof(double));
    double (* sum_qsd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(k*sizeof(double [NBDirsMax])*
        NBDirsMax);
    double *xcentered = (double *)malloc(d*sizeof(double));
    double (* xcenteredd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(d*sizeof(double [NBDirsMax])*
        NBDirsMax);
    double *Qxcentered = (double *)malloc(d*sizeof(double));
    double (* Qxcenteredd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(d*sizeof(double [NBDirsMax])
        *NBDirsMax);
    double *main_term = (double *)malloc(k*sizeof(double));
    double (* main_termd)[NBDirsMax] = (double (*)[NBDirsMax])malloc(k*sizeof(double [NBDirsMax])*
        NBDirsMax);

    preprocess_qs_dv(d, k, icf, (double (*)[NBDirsMax]) icfd, &(sum_qs[0]), &(sum_qsd[0]), &(Qdiags[0]), &(Qdiagsd[0]), nbdirs);
    double slse = 0;
    double slsed[NBDirsMax];
    for (nd = 0; nd < NBDirsMax; ++nd)
        slsed[nd] = 0.0;
    for (ix = 0; ix < n; ++ix) {
        for (ik = 0; ik < k; ++ik) {
            subtract_dv(d, &(x[ix*d]), &(means[ik*d]), &(((double (*)[NBDirsMax])meansd)[ik*d]), &(
                        xcentered[0]), &(xcenteredd[0]), nbdirs);
            Qtimesx_dv(d, &(Qdiags[ik*d]), &(Qdiagsd[ik*d]), &(icf[ik*icf_sz +
                       d]), &(((double (*)[NBDirsMax]) icfd)[ik*icf_sz + d]), &(xcentered[0]), &(
                       xcenteredd[0]), &(Qxcentered[0]), &(Qxcenteredd[0]), 
                       nbdirs);
            // two caches for qxcentered at idx 0 and at arbitrary index
            sqnorm_dv(d, &(Qxcentered[0]), &(Qxcenteredd[0]), &result1, 
                      result1d, nbdirs);
            for (nd = 0; nd < nbdirs; ++nd)
                main_termd[ik][nd] = ((double (*)[NBDirsMax]) alphasd)[ik][nd] + sum_qsd[ik][nd] - 0.5*
                    result1d[nd];
            main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5*result1;
        }
        // storing cmp for max of main_term
        // 2 x (0 and arbitrary) storing sub to exp
        // storing sum for use in log
        log_sum_exp_dv(k, &(main_term[0]), &(main_termd[0]), &result1, 
                       result1d, nbdirs);
        for (nd = 0; nd < nbdirs; ++nd)
            slsed[nd] = slsed[nd] + result1d[nd];
        slse = slse + result1;
    }
    double lse_alphas;
    double lse_alphasd[NBDirsMax];
    log_sum_exp_dv(k, alphas, (double (*)[NBDirsMax]) alphasd, &lse_alphas, lse_alphasd, nbdirs);
    log_wishart_prior_dv(d, k, wishart, &(sum_qs[0]), &(sum_qsd[0]), &(Qdiags[
                         0]), &(Qdiagsd[0]), icf, (double (*)[NBDirsMax]) icfd, &result1, result1d, 
                         nbdirs);
    for (nd = 0; nd < nbdirs; ++nd)
        (* ((double (*)[NBDirsMax]) errd))[nd] = slsed[nd] - n*lse_alphasd[nd] + result1d[nd];
    *err = CONSTANT + slse - n*lse_alphas + result1;

    free(Qdiagsd);
    free(Qdiags);
    free(sum_qsd);
    free(sum_qs);
    free(xcenteredd);
    free(xcentered);
    free(Qxcenteredd);
    free(Qxcentered);
    free(main_termd);
    free(main_term);
}


//! Adept
#include <adept.h>
#include <adept_arrays.h>
#include <adept_source.h>
using adept::adouble;
using adept::aVector;

namespace adeptTest {

// out = a - b
template <typename T1, typename T2, typename T3>
void subtract(int d, const T1 *const x, const T2 *const y, T3 *out) {
  for (int id = 0; id < d; id++) {
    out[id] = x[id] - y[id];
  }
}

template <typename T> T sqnorm(int n, const T *const x) {
  T res = x[0] * x[0];
  for (int i = 1; i < n; i++)
    res = res + x[i] * x[i];
  return res;
}

// This throws error on n<1
template <typename T> T arr_max(int n, const T *const x) {
  T m = x[0];
  for (int i = 1; i < n; i++) {
    if (m < x[i])
      m = x[i];
  }
  return m;
}

template <typename T>
void gmm_objective(int d, int k, int n, const T *const alphas,
                   const T *const means, const T *const icf,
                   const double *const x, Wishart wishart, T *err);

// split of the outer loop over points
template <typename T>
void gmm_objective_split_inner(int d, int k, const T *const alphas,
                               const T *const means, const T *const icf,
                               const double *const x, Wishart wishart, T *err);
// other terms which are outside the loop
template <typename T>
void gmm_objective_split_other(int d, int k, int n, const T *const alphas,
                               const T *const means, const T *const icf,
                               Wishart wishart, T *err);

template <typename T> T logsumexp(int n, const T *const x);

// p: dim
// k: number of components
// wishart parameters
// sum_qs: k sums of log diags of Qs
// Qdiags: d*k
// icf: (p*(p+1)/2)*k inverse covariance factors
template <typename T>
T log_wishart_prior(int p, int k, Wishart wishart, const T *const sum_qs,
                    const T *const Qdiags, const T *const icf);

template <typename T>
void preprocess_qs(int d, int k, const T *const icf, T *sum_qs, T *Qdiags);

template <typename T>
void Qtimesx(int d, const T *const Qdiag,
             const T *const ltri, // strictly lower triangular part
             const T *const x, T *out);

////////////////////////////////////////////////////////////
//////////////////// Definitions ///////////////////////////
////////////////////////////////////////////////////////////

template <typename T> T logsumexp(int n, const T *const x) {
  T mx = arr_max(n, x);
  T semx = 0.;
  for (int i = 0; i < n; i++) {
    semx = semx + exp(x[i] - mx);
  }
  return log(semx) + mx;
}

template <typename T>
T log_wishart_prior(int p, int k, Wishart wishart, const T *const sum_qs,
                    const T *const Qdiags, const T *const icf) {
  int n = p + wishart.m + 1;
  int icf_sz = p * (p + 1) / 2;

  double C = n * p * (log(wishart.gamma) - 0.5 * log(2)) -
             log_gamma_distrib(0.5 * n, p);

  T out = 0;
  for (int ik = 0; ik < k; ik++) {
    T frobenius =
        sqnorm(p, &Qdiags[ik * p]) + sqnorm(icf_sz - p, &icf[ik * icf_sz + p]);
    out = out + 0.5 * wishart.gamma * wishart.gamma * (frobenius)-wishart.m *
                    sum_qs[ik];
  }

  return out - k * C;
}

template <typename T>
void preprocess_qs(int d, int k, const T *const icf, T *sum_qs, T *Qdiags) {
  int icf_sz = d * (d + 1) / 2;
  for (int ik = 0; ik < k; ik++) {
    sum_qs[ik] = 0.;
    for (int id = 0; id < d; id++) {
      T q = icf[ik * icf_sz + id];
      sum_qs[ik] = sum_qs[ik] + q;
      Qdiags[ik * d + id] = exp(q);
    }
  }
}

template <typename T>
void Qtimesx(int d, const T *const Qdiag,
             const T *const ltri, // strictly lower triangular part
             const T *const x, T *out) {
  for (int id = 0; id < d; id++)
    out[id] = Qdiag[id] * x[id];

  int Lparamsidx = 0;
  for (int i = 0; i < d; i++) {
    for (int j = i + 1; j < d; j++) {
      out[j] = out[j] + ltri[Lparamsidx] * x[i];
      Lparamsidx++;
    }
  }
}

template <typename T>
void gmm_objective(int d, int k, int n, const T *const alphas,
                   const T *const means, const T *const icf,
                   const double *const x, Wishart wishart, T *err) {
  const double CONSTANT = -n * d * 0.5 * log(2 * PI);
  int icf_sz = d * (d + 1) / 2;

  vector<T> Qdiags(d * k);
  vector<T> sum_qs(k);
  vector<T> xcentered(d);
  vector<T> Qxcentered(d);
  vector<T> main_term(k);

  preprocess_qs(d, k, icf, &sum_qs[0], &Qdiags[0]);

  T slse = 0.;
  for (int ix = 0; ix < n; ix++) {
    for (int ik = 0; ik < k; ik++) {
      subtract(d, &x[ix * d], &means[ik * d], &xcentered[0]);
      Qtimesx(d, &Qdiags[ik * d], &icf[ik * icf_sz + d], &xcentered[0],
              &Qxcentered[0]);

      main_term[ik] = alphas[ik] + sum_qs[ik] - 0.5 * sqnorm(d, &Qxcentered[0]);
    }
    slse = slse + logsumexp(k, &main_term[0]);
  }

  T lse_alphas = logsumexp(k, alphas);

  *err = CONSTANT + slse - n * lse_alphas;

  *err = *err + log_wishart_prior(d, k, wishart, &sum_qs[0], &Qdiags[0], icf);
}

template <typename T>
void gmm_objective_split_inner(int d, int k, const T *const alphas,
                               const T *const means, const T *const icf,
                               const double *const x, Wishart wishart, T *err) {
  int icf_sz = d * (d + 1) / 2;

  T *Ldiag = new T[d];
  T *xcentered = new T[d];
  T *mahal = new T[d];
  T *lse = new T[k];

  for (int ik = 0; ik < k; ik++) {
    int icf_off = ik * icf_sz;
    T sumlog_Ldiag(0.);
    for (int id = 0; id < d; id++) {
      sumlog_Ldiag = sumlog_Ldiag + icf[icf_off + id];
      Ldiag[id] = exp(icf[icf_off + id]);
    }

    for (int id = 0; id < d; id++) {
      xcentered[id] = x[id] - means[ik * d + id];
      mahal[id] = Ldiag[id] * xcentered[id];
    }
    int Lparamsidx = d;
    for (int i = 0; i < d; i++) {
      for (int j = i + 1; j < d; j++) {
        mahal[j] = mahal[j] + icf[icf_off + Lparamsidx] * xcentered[i];
        Lparamsidx++;
      }
    }
    T sqsum_mahal(0.);
    for (int id = 0; id < d; id++) {
      sqsum_mahal = sqsum_mahal + mahal[id] * mahal[id];
    }

    lse[ik] = alphas[ik] + sumlog_Ldiag - 0.5 * sqsum_mahal;
  }

  *err = logsumexp(k, lse);

  delete[] mahal;
  delete[] xcentered;
  delete[] Ldiag;
  delete[] lse;
}

template <typename T>
void gmm_objective_split_other(int d, int k, int n, const T *const alphas,
                               const T *const means, const T *const icf,
                               Wishart wishart, T *err) {
  const double CONSTANT = -n * d * 0.5 * log(2 * PI);

  T lse_alphas = logsumexp(k, alphas);

  T *sum_qs = new T[k];
  T *Qdiags = new T[d * k];
  preprocess_qs(d, k, icf, sum_qs, Qdiags);
  *err = CONSTANT - n * lse_alphas +
         log_wishart_prior(d, k, wishart, sum_qs, Qdiags, icf);
  delete[] sum_qs;
  delete[] Qdiags;
}

}; // namespace adeptTest

void adept_dgmm_objective(int d, int k, int n, const double *alphas,
                          double *alphasb, const double *means, double *meansb,
                          const double *icf, double *icfb, const double *x,
                          Wishart wishart, double *err, double *errb) {

  int icf_sz = d * (d + 1) / 2;
  int Jrows = 1;
  int Jcols = (k * (d + 1) * (d + 2)) / 2;

  adept::Stack stack;
  adouble *aalphas = new adouble[k];
  adouble *ameans = new adouble[d * k];
  adouble *aicf = new adouble[icf_sz * k];

  adept::set_values(aalphas, k, alphas);
  adept::set_values(ameans, d * k, means);
  adept::set_values(aicf, icf_sz * k, icf);

  stack.new_recording();
  adouble aerr;

  adeptTest::gmm_objective(d, k, n, aalphas, ameans, aicf, x, wishart, &aerr);

  adept::set_gradients(aalphas, k, alphasb);
  adept::set_gradients(ameans, d * k, meansb);
  adept::set_gradients(aicf, icf_sz * k, icfb);

  stack.compute_tangent_linear();

  *errb = aerr.get_gradient();

  delete[] aalphas;
  delete[] ameans;
  delete[] aicf;
}
