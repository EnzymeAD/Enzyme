module Enzyme

export autodiff
export Const, Active, Duplicated

using LLVM
using LLVM.Interop
using Libdl
using Cassette

include("utils.jl")
include("compiler.jl")

abstract type Annotation{T} end 
struct Const{T} <: Annotation{T}
    val::T
end
struct Active{T} <: Annotation{T}
    val::T
end
struct Duplicated{T} <: Annotation{T}
    val::T
    dval::T
end

Base.eltype(::Type{<:Annotation{T}}) where T = T

struct LLVMThunk
    mod::LLVM.Module
    entry::LLVM.Function

    function LLVMThunk(f, rt, tt; optimize=true, run_enzyme=true)
        primal_tt = map(eltype, tt) 

        # CTX, f are ghosts
        name   = String(nameof(f))
        source = Compiler.FunctionSpec(Cassette.overdub, Tuple{typeof(Compiler.CTX), typeof(f), primal_tt...}, #=kernel=# false, #=name=# name)
        target = Compiler.EnzymeTarget()
        job    = Compiler.EnzymeJob(target, source)

        # Codegen the primal function and all its dependency in one module
        mod, primalf = Compiler.codegen(:llvm, job, optimize=false)

        # Now build the actual wrapper function
        ctx     = context(mod)
        rettype = convert(LLVMType, rt)

        params = parameters(primalf)
        adjoint_tt = LLVMType[]
        for (i, T) in enumerate(tt)
            llvmT = llvmtype(params[i])
            push!(adjoint_tt, llvmT)
            if T <: Duplicated 
                push!(adjoint_tt, llvmT)
            end
        end

        # create a wrapper Function that we will inline into the llvmcall
        # generated by `call_function` in `autodiff`
        llvmf = LLVM.Function(mod, "enzyme_entry", LLVM.FunctionType(rettype, adjoint_tt))
        push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))

        # Create the FunctionType and funtion decleration for the intrinsic
        pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
        ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
        autodiff = LLVM.Function(mod, string("__enzyme_autodiff.", rt), ftd)

        params = LLVM.Value[]
        llvm_params = parameters(llvmf)
        i = 1
        for T in tt
            if T <: Const
                push!(params, MDString("diffe_const"))
            elseif T <: Active
                push!(params, MDString("diffe_out"))
            elseif T <: Duplicated
                push!(params, MDString("diffe_dup"))
                push!(params, llvm_params[i])
                i += 1
            else
                @assert("illegal annotation type")
            end
            push!(params, llvm_params[i])
            i += 1
        end

        Builder(ctx) do builder
            entry = BasicBlock(llvmf, "entry", ctx)
            position!(builder, entry)

            tc = bitcast!(builder, primalf,  pt)
            pushfirst!(params, tc)

            val = call!(builder, autodiff, params)

            ret!(builder, val)
        end

        if optimize
            # Run pipeline and Enzyme pass
            Compiler.optimize!(mod, llvmf, run_enzyme=run_enzyme)
        end
        strip_debuginfo!(mod)

        new(mod, llvmf)
    end
end

struct Thunk{Ptr, RT, TT}
    function Thunk(f, rt, tt)
        thunk = LLVMThunk(f, rt, tt)
        triple = LLVM.triple()
        target = LLVM.Target(triple)
        objfile = tempname()
        libfile = tempname()
        TargetMachine(target, triple, "", "", LLVM.API.LLVMCodeGenLevelDefault, LLVM.API.LLVMRelocPIC) do tm
            LLVM.emit(tm, thunk.mod, LLVM.API.LLVMObjectFile, objfile)
        end

        run(`ld -shared $objfile -o $libfile`)
        libptr = Libdl.dlopen(libfile, Libdl.RTLD_LOCAL)
        ptr = Libdl.dlsym(libptr, :enzyme_entry)

        return new{ptr, rt, Tuple{tt...}}()
    end
end

# https://github.com/JuliaGPU/GPUCompiler.jl/issues/3
# We are also re-running Julia's optimization pipeline again
# @generated function (thunk::Thunk{F, RT, TT, LLVMF})(args...) where {F, RT, TT, LLVMF}
#     _args = (:(args[$i]) for i in 1:length(args))
#     call_function(LLVMF, Float64, Tuple{args...}, Expr(:tuple, _args...))
# end

# Now this is just getting worse...
@generated function (thunk::Thunk{Ptr, RT})(args...) where {Ptr, RT}
    _args = (:(args[$i]) for i in 1:length(args))
    quote
        ccall($Ptr, $RT, ($(args...),), $(_args...))
    end
end

function enzyme_code_llvm(io::IO, @nospecialize(func), @nospecialize(types); 
                   optimize::Bool=true, run_enzyme::Bool=true, raw::Bool=false,
                   debuginfo::Symbol=:default, dump_module::Bool=false)
    thunk = LLVMThunk(func, Float64, types, optimize=optimize, run_enzyme=run_enzyme)

    str = ccall(:jl_dump_function_ir, Ref{String},
                (Ptr{Cvoid}, Bool, Bool, Ptr{UInt8}),
                LLVM.ref(thunk.entry), !raw, dump_module, debuginfo)
    print(io, str)
end
enzyme_code_llvm(@nospecialize(func), @nospecialize(types); kwargs...) = enzyme_code_llvm(stdout, func, types; kwargs...)

annotate() = ()
annotate(arg::Annotation, args...) = (arg, annotate(args...)...)
annotate(arg, args...) = (Const(arg), annotate(args...)...)

prepare_cc() = ()
prepare_cc(arg::Duplicated, args...) = (arg.val, arg.dval, prepare_cc(args...)...)
prepare_cc(arg::Annotation, args...) = (arg.val, prepare_cc(args...)...)

function autodiff(f, args...)
    args′ =  annotate(args...)
    thunk = Thunk(f, Float64, map(Core.Typeof, args′))
    thunk(prepare_cc(args′...)...)
end

import .Compiler: EnzymeCtx
# Ops that have intrinsics
for op in (sin, cos, exp)
    for (T, suffix) in ((Float32, "f32"), (Float64, "f64"))
        llvmf = "llvm.$(nameof(op)).$suffix"
        @eval begin
            @inline function Cassette.overdub(::EnzymeCtx, ::typeof($op), x::$T)
                ccall($llvmf, llvmcall, $T, ($T,), x)
            end
        end
    end
end

# WIP
# @inline Cassette.overdub(::EnzymeCtx, ::typeof(asin), x::Float64) = ccall(:asin, Float64, (Float64,), x)
# @inline Cassette.overdub(::EnzymeCtx, ::typeof(asin), x::Float32) = ccall(:asin, Float32, (Float32,), x)
end # module
