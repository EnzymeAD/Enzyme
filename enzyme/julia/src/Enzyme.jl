module Enzyme

export autodiff

using LLVM
using LLVM.Interop

include("utils.jl")
include("ad.jl")
include("compiler.jl")

struct Thunk{F, RT, TT, LLVMF}
    mod::LLVM.Module
    entry::LLVM.Function

    function Thunk(f, rt, tt)
        # Drop from the signature the Enzyme calling-convetion
        diffetypes = []
        autodifftypes = []
        i = 1
        while i <= length(tt)
            push!(autodifftypes, tt[i])
            dt = whatType(tt[i])
            push!(diffetypes, dt)
            if dt == "diffe_dup"
                i+=1
            end
            i+=1
        end

        source = Compiler.FunctionSpec(f, Base.to_tuple_type(autodifftypes), #=kernel=# false)
        target = Compiler.EnzymeTarget()
        job    = Compiler.EnzymeJob(target, source)

        # Codegen the primal function and all its dependency in one module
        mod, primalf = Compiler.codegen(:llvm, job, optimize=false)

        # Now build the actual wrapper function
        ctx     = context(mod)
        rettype = convert(LLVMType, rt)

        i = 1
        orig_params = parameters(primalf)
        argtypes2   = LLVMType[]
        for p in orig_params
            push!(argtypes2, llvmtype(p))
            if diffetypes[i] == "diffe_dup"
                push!(argtypes2, llvmtype(p))
                i+=2
            else
                i+=1
            end
        end

        # TODO get function type from primalf
        ft2  = LLVM.FunctionType(rettype, argtypes2)

        # create a wrapper Function that we will inline into the llvmcall
        # generated by `call_function` in `autodiff`
        llvmf = LLVM.Function(mod, "enzyme_entry", ft2)
        push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))

        # Create the FunctionType and funtion decleration for the intrinsic
        pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
        ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
        autodiff = LLVM.Function(mod, "__enzyme_autodiff", ftd)

        params = LLVM.Value[]
        i = 1
        j = 1
        llvm_params = parameters(llvmf)
        while j <= length(tt)
            push!(params, MDString(diffetypes[i]))
            if diffetypes[i] == "diffe_dup"
                push!(params, llvm_params[j])
                j+=1
            end
            push!(params, llvm_params[j])
            j += 1
            i += 1
        end

        Builder(ctx) do builder
            entry = BasicBlock(llvmf, "entry", ctx)
            position!(builder, entry)

            tc = bitcast!(builder, primalf,  pt)
            pushfirst!(params, tc)

            val = call!(builder, autodiff, params)

            ret!(builder, val)
        end

        # Run pipeline and Enzyme pass
        Compiler.optimize!(job, mod, llvmf)
        strip_debuginfo!(mod)

        new{typeof(f), rt, Tuple{tt...}, llvmf}(mod, llvmf)
    end
end

# This is rather wonky... we should instead integrate with the ORCJIT C-API
# https://github.com/JuliaGPU/GPUCompiler.jl/issues/3
# We are also re-running Julia's optimization pipeline again
@generated function (thunk::Thunk{F, RT, TT, LLVMF})(args...) where {F, RT, TT, LLVMF}
    _args = (:(args[$i]) for i in 1:length(args))
    call_function(LLVMF, Float64, Tuple{args...}, Expr(:tuple, _args...))
end

function autodiff(f, args...)
    thunk = Thunk(f, Float64, map(Core.Typeof, args))
    thunk(args...)
end
   
end # module
