module Enzyme

export autodiff

using LLVM
using LLVM.Interop
import MCAnalyzer: irgen

include("utils.jl")
include("ad.jl")
include("opt.jl")

using .Opt: optimize!

function emit(f, args)
    # Obtain the function and all it's dependencies in one handy module
    diffetypes = []
    autodifftypes = Type[f]
    i = 1
    while i <= length(args)
        push!(autodifftypes, args[i])
        dt = whatType(args[i])
        push!(diffetypes, dt)
        if dt == "diffe_dup"
            i+=1
        end
        i+=1
    end
    mod, ccf = irgen(Tuple{autodifftypes...}) 

    ctx = context(mod)
    rettype = convert(LLVMType, Float64)
    
    #argtypes2 = LLVMType[convert(LLVMType, T, true) for T in args]
    argtypes2 = LLVMType[]
    
    i = 1
    j = 1
    orig_params = parameters(ccf)
    for p in orig_params
        push!(argtypes2, llvmtype(p))
        if diffetypes[i] == "diffe_dup"
            push!(argtypes2, llvmtype(p))
            i+=2
        else
            i+=1
        end
    end

    # TODO get function type from ccf
    ft2  = LLVM.FunctionType(rettype, argtypes2)

    # create a wrapper Function that we will inline into the llvmcall
    # generated by in the end `call_function`
    llvmf = LLVM.Function(mod, "enzyme_entry", ft2)
    push!(function_attributes(llvmf), EnumAttribute("alwaysinline", 0, ctx))

    # Create the FunctionType and funtion decleration for the intrinsic
    pt       = LLVM.PointerType(LLVM.Int8Type(ctx))
    ftd      = LLVM.FunctionType(rettype, LLVMType[pt], true)
    autodiff = LLVM.Function(mod, "__enzyme_autodiff", ftd)

    params = LLVM.Value[]
    i = 1
    j = 1
    llvm_params = parameters(llvmf)
    while j <= length(args)
        push!(params, MDString(diffetypes[i]))
        if diffetypes[i] == "diffe_dup"
            push!(params, llvm_params[j])
            j+=1
        end
        push!(params, llvm_params[j])
        j += 1
        i += 1
    end

    Builder(ctx) do builder
        entry = BasicBlock(llvmf, "entry", ctx)
        position!(builder, entry)

        tc = bitcast!(builder, ccf, pt)
        pushfirst!(params, tc)

        val = call!(builder, autodiff, params)

        #if T === Nothing
        #    ret!(builder)
        #else
            ret!(builder, val)
        #end
    end

    llvmf, mod
end

@generated function autodiff(f, args...)
    llvmf, mod = emit(f, args)

    # Run pipeline and Enzyme pass
    optimize!(mod)
    strip_debuginfo!(mod)

    _args = (:(args[$i]) for i in 1:length(args))
    call_function(llvmf, Float64, Tuple{args...}, Expr(:tuple, _args...))
end
   
end # module
