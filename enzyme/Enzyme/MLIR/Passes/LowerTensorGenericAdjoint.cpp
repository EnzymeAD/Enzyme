//===- LowerTensorGenericAdjoint.cpp - Lower Shadowed Gradient ops
//------------------ //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements a pass to lower custom ops generated by the Enzyme AD
// procedure to the MemRef dialect.
//===----------------------------------------------------------------------===//

#include "Dialect/Dialect.h"
#include "Dialect/Ops.h"
#include "PassDetails.h"
#include "Passes/Passes.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Transforms/DialectConversion.h"

#include "mlir/Rewrite/PatternApplicator.h"
#include "llvm/Support/raw_ostream.h"

#include "Interfaces/AutoDiffTypeInterface.h"
#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Linalg/IR/Linalg.h"

#include "Utils.h"

using namespace mlir;
using namespace enzyme;
using llvm::errs;
namespace {

struct LowerTensorGenericAdjointPass
    : public enzyme::LowerTensorGenericAdjointPassBase<LowerTensorGenericAdjointPass> {
  void runOnOperation() override {
    MLIRContext *context = &getContext();
    ConversionPatternRewriter rewriter(context);

    getOperation()->walk([&](Operation *op) {
      auto loc = op->getLoc();
      auto enzymeAdjoint = dyn_cast<enzyme::GenericAdjointOp>(op);
      if (!enzymeAdjoint)
        return;
      
      if (enzymeAdjoint->getNumResults() == 0) // Check if has buffer semantics TODO?
        return;

      OpBuilder cacheBuilder(enzymeAdjoint);
      auto adjoint = Utils::adjointToGeneric(enzymeAdjoint, cacheBuilder, loc);

      // check if adjoint contains a enzyme.addToOp
      Operation *addToOp = nullptr;
      adjoint.walk([&](Operation *op) {
        if (isa<enzyme::AddToOp>(op)) {
          addToOp = op;
        }
      });
      if (!addToOp)
        return;
      
      SmallVector<Value> retargs;
      for (auto val : addToOp->getOperands()) {
        retargs.push_back(val);
      }

      Operation *terminator = adjoint.getBodyRegion().front().getTerminator();
      cacheBuilder.setInsertionPoint(terminator);

      cacheBuilder.create<linalg::YieldOp>(loc, ValueRange{retargs});
      addToOp->erase();
    });
  };
};
} // end anonymous namespace

namespace mlir {
namespace enzyme {
std::unique_ptr<Pass> createLowerTensorGenericAdjointPass() {
  return std::make_unique<LowerTensorGenericAdjointPass>();
}
} // namespace enzyme
} // namespace mlir
