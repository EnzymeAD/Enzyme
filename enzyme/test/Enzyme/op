; ModuleID = '<stdin>'
source_filename = "<stdin>"

define linkonce_odr dso_local void @f(double* %x, double* %z, i64* %rows) {
entry:
  br label %loop1

loop1:                                            ; preds = %cleanup, %entry
  %a17 = phi i64 [ 4, %entry ], [ %.pre, %cleanup ]
  %k = phi i64 [ 0, %entry ], [ %k1, %cleanup ]
  %X1 = getelementptr inbounds double, double* %x, i64 %k
  %L1 = load double, double* %X1
  br label %loop2

loop2:                                            ; preds = %loop2, %loop1
  %j = phi i64 [ %j1, %loop2 ], [ 0, %loop1 ]
  %X2 = getelementptr inbounds double, double* %x, i64 %j
  %L2 = load double, double* %X2
  %why = fmul fast double %L1, %L2
  %tostore = getelementptr inbounds double, double* %z, i64 %a17
  store double %why, double* %tostore
  %j1 = add nuw nsw i64 %j, 1
  %exit2 = icmp eq i64 %j1, 4
  br i1 %exit2, label %cleanup, label %loop2

cleanup:                                          ; preds = %loop2
  %k1 = add nuw nsw i64 %k, 1
  %.pre = load i64, i64* %rows
  %exit1 = icmp eq i64 %k1, 4
  br i1 %exit1, label %exit, label %loop1

exit:                                             ; preds = %cleanup
  ret void
}

define dso_local void @dsum(double* %x, double* %xp, double* %z, double* %zp, i64* %n, i64* %np) {
entry:
  %0 = call {} @diffef(double* %x, double* %xp, double* %z, double* %zp, i64* %n)
  ret void
}

declare double @__enzyme_autodiff(void (double*, double*, i64*)*, ...)

define linkonce_odr dso_local void @preprocess_f(double* %x, double* %z, i64* %rows) {
entry:
  br label %loop1

loop1:                                            ; preds = %cleanup, %entry
  %a17 = phi i64 [ 4, %entry ], [ %.pre, %cleanup ]
  %k = phi i64 [ 0, %entry ], [ %k1, %cleanup ]
  %X1 = getelementptr inbounds double, double* %x, i64 %k
  %L1 = load double, double* %X1
  br label %loop2

loop2:                                            ; preds = %loop2, %loop1
  %j = phi i64 [ %j1, %loop2 ], [ 0, %loop1 ]
  %X2 = getelementptr inbounds double, double* %x, i64 %j
  %L2 = load double, double* %X2
  %why = fmul fast double %L1, %L2
  %tostore = getelementptr inbounds double, double* %z, i64 %a17
  store double %why, double* %tostore
  %j1 = add nuw nsw i64 %j, 1
  %exit2 = icmp eq i64 %j1, 4
  br i1 %exit2, label %cleanup, label %loop2

cleanup:                                          ; preds = %loop2
  %k1 = add nuw nsw i64 %k, 1
  %.pre = load i64, i64* %rows
  %exit1 = icmp eq i64 %k1, 4
  br i1 %exit1, label %exit, label %loop1

exit:                                             ; preds = %cleanup
  ret void
}

define internal {} @diffef(double* %x, double* %"x'", double* %z, double* %"z'", i64* %rows) {
entry:
  %malloccall = tail call noalias nonnull i8* @malloc(i64 32)
  %L1_malloccache = bitcast i8* %malloccall to double*
  %malloccall3 = tail call noalias nonnull i8* @malloc(i64 32)
  %a17_malloccache = bitcast i8* %malloccall3 to i64*
  %malloccall5 = tail call noalias nonnull i8* @malloc(i64 128)
  %L2_malloccache = bitcast i8* %malloccall5 to double*
  br label %loop1

loop1:                                            ; preds = %cleanup, %entry
  %iv = phi i64 [ %iv.next, %cleanup ], [ 0, %entry ]
  %a17 = phi i64 [ 4, %entry ], [ %.pre, %cleanup ]
  %0 = getelementptr i64, i64* %a17_malloccache, i64 %iv
  store i64 %a17, i64* %0
  %iv.next = add nuw i64 %iv, 1
  %X1 = getelementptr inbounds double, double* %x, i64 %iv
  %L1 = load double, double* %X1
  %1 = getelementptr double, double* %L1_malloccache, i64 %iv
  store double %L1, double* %1
  br label %loop2

loop2:                                            ; preds = %loop2, %loop1
  %iv1 = phi i64 [ %iv.next2, %loop2 ], [ 0, %loop1 ]
  %iv.next2 = add nuw i64 %iv1, 1
  %X2 = getelementptr inbounds double, double* %x, i64 %iv1
  %L2 = load double, double* %X2
  %2 = mul nuw i64 %iv1, 4
  %3 = add nuw i64 %iv, %2
  %4 = getelementptr double, double* %L2_malloccache, i64 %3
  store double %L2, double* %4
  %why = fmul fast double %L1, %L2
  %tostore = getelementptr inbounds double, double* %z, i64 %a17
  store double %why, double* %tostore
  %exit2 = icmp eq i64 %iv.next2, 4
  br i1 %exit2, label %cleanup, label %loop2

cleanup:                                          ; preds = %loop2
  %.pre = load i64, i64* %rows
  %exit1 = icmp eq i64 %iv.next, 4
  br i1 %exit1, label %invertcleanup, label %loop1

invertentry:                                      ; preds = %invertloop1
  tail call void @free(i8* nonnull %malloccall5)
  tail call void @free(i8* nonnull %malloccall3)
  tail call void @free(i8* nonnull %malloccall)
  ret {} undef

invertloop1:                                      ; preds = %invertloop2
  %"X1'ipg" = getelementptr double, double* %"x'", i64 %"iv'ac.0"
  %5 = load double, double* %"X1'ipg"
  %6 = fadd fast double %5, %18
  store double %6, double* %"X1'ipg"
  %7 = icmp eq i64 %"iv'ac.0", 0
  br i1 %7, label %invertentry, label %incinvertloop1

incinvertloop1:                                   ; preds = %invertloop1
  %8 = sub nuw nsw i64 %"iv'ac.0", 1
  br label %invertcleanup

invertloop2:                                      ; preds = %invertcleanup, %incinvertloop2
  %"L1'de.0" = phi double [ 0.000000e+00, %invertcleanup ], [ %18, %incinvertloop2 ]
  %"iv1'ac.0" = phi i64 [ 3, %invertcleanup ], [ %22, %incinvertloop2 ]
  %9 = getelementptr i64, i64* %a17_malloccache, i64 %"iv'ac.0"
  %10 = load i64, i64* %9, !invariant.load !0
  %"tostore'ipg" = getelementptr double, double* %"z'", i64 %10
  %11 = load double, double* %"tostore'ipg"
  %"tostore'ipg4" = getelementptr double, double* %"z'", i64 %10
  store double 0.000000e+00, double* %"tostore'ipg4"
  %12 = mul nuw i64 %"iv1'ac.0", 4
  %13 = add nuw i64 %"iv'ac.0", %12
  %14 = getelementptr double, double* %L2_malloccache, i64 %13
  %15 = load double, double* %14, !invariant.load !0
  %m0diffeL1 = fmul fast double %11, %15
  %16 = getelementptr double, double* %L1_malloccache, i64 %"iv'ac.0"
  %17 = load double, double* %16, !invariant.load !0
  %m1diffeL2 = fmul fast double %11, %17
  %18 = fadd fast double %"L1'de.0", %m0diffeL1
  %"X2'ipg" = getelementptr double, double* %"x'", i64 %"iv1'ac.0"
  %19 = load double, double* %"X2'ipg"
  %20 = fadd fast double %19, %m1diffeL2
  store double %20, double* %"X2'ipg"
  %21 = icmp eq i64 %"iv1'ac.0", 0
  br i1 %21, label %invertloop1, label %incinvertloop2

incinvertloop2:                                   ; preds = %invertloop2
  %22 = sub nuw nsw i64 %"iv1'ac.0", 1
  br label %invertloop2

invertcleanup:                                    ; preds = %cleanup, %incinvertloop1
  %"iv'ac.0" = phi i64 [ %8, %incinvertloop1 ], [ 3, %cleanup ]
  br label %invertloop2
}

declare i8* @realloc(i8*, i64)

declare noalias i8* @malloc(i64)

declare void @free(i8*)

!0 = !{}
