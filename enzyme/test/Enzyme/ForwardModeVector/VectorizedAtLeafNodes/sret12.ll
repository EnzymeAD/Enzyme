; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs
; RUN: if [ %llvmver -ge 12 ]; then %opt < %s %loadEnzyme -enzyme -enzyme-preopt=false -enzyme-vectorize-at-leaf-nodes -mem2reg -simplifycfg -early-cse -S | FileCheck %s ; fi

; #include <stdio.h>
; #include <array>

; using namespace std;

; typedef double double4 __attribute__((ext_vector_type(4)));

; extern int enzyme_width;

; extern array<double4,3> __enzyme_fwddiff(void*, ...);

; array<double,3> square(double *x) {
;     return {*x * *x, *x * *x * *x, *x};
; }

; array<double4,3> dsquare(double *x, double4 *dx) {
;     // This returns the derivative of square or 2 * x
;     return __enzyme_fwddiff((void*)square, enzyme_width, 4, x, dx);
; }

; int main() {
;     double x = 3.0;
;     double4 dx = {1.0, 2.0, 3.0, 4.0};
;     printf("%f \n", dsquare(&x, &dx)[0][0]);
; }


%"struct.std::array" = type { [3 x double] }
%"struct.std::array.0" = type { [3 x <4 x double>] }

@enzyme_width = external dso_local local_unnamed_addr global i32, align 4
@.str = private unnamed_addr constant [5 x i8] c"%f \0A\00", align 1

define dso_local void @_Z6squarePd(%"struct.std::array"* noalias nocapture writeonly sret(%"struct.std::array") align 8 %agg.result, double* nocapture noundef readonly %x) #0 {
entry:
  %arrayinit.begin = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 0
  %0 = load double, double* %x, align 8
  %mul = fmul double %0, %0
  store double %mul, double* %arrayinit.begin, align 8
  %arrayinit.element = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 1
  %mul2 = fmul double %0, %mul
  store double %mul2, double* %arrayinit.element, align 8
  %arrayinit.element3 = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 2
  store double %0, double* %arrayinit.element3, align 8
  ret void
}

define dso_local void @_Z7dsquarePdPDv4_d(%"struct.std::array.0"* noalias sret(%"struct.std::array.0") align 32 %agg.result, double* noundef %x, <4 x double>* noundef %dx) local_unnamed_addr #1 {
entry:
  %0 = load i32, i32* @enzyme_width, align 4
  call void (%"struct.std::array.0"*, i8*, ...) @_Z16__enzyme_fwddiffPvz(%"struct.std::array.0"* sret(%"struct.std::array.0") align 32 %agg.result, i8* noundef bitcast (void (%"struct.std::array"*, double*)* @_Z6squarePd to i8*), i32 noundef %0, i32 noundef 4, double* noundef %x, <4 x double>* noundef %dx)
  ret void
}

declare dso_local void @_Z16__enzyme_fwddiffPvz(%"struct.std::array.0"* sret(%"struct.std::array.0") align 32, i8* noundef, ...) local_unnamed_addr #2

define dso_local noundef i32 @main() local_unnamed_addr #3 {
entry:
  %x = alloca double, align 8
  %dx = alloca <4 x double>, align 32
  %ref.tmp = alloca %"struct.std::array.0", align 32
  %0 = bitcast double* %x to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0) #6
  store double 3.000000e+00, double* %x, align 8
  %1 = bitcast <4 x double>* %dx to i8*
  call void @llvm.lifetime.start.p0i8(i64 32, i8* nonnull %1) #6
  store <4 x double> <double 1.000000e+00, double 2.000000e+00, double 3.000000e+00, double 4.000000e+00>, <4 x double>* %dx, align 32
  %2 = bitcast %"struct.std::array.0"* %ref.tmp to i8*
  call void @llvm.lifetime.start.p0i8(i64 96, i8* nonnull %2) #6
  %3 = load i32, i32* @enzyme_width, align 4
  call void (%"struct.std::array.0"*, i8*, ...) @_Z16__enzyme_fwddiffPvz(%"struct.std::array.0"* nonnull sret(%"struct.std::array.0") align 32 %ref.tmp, i8* noundef bitcast (void (%"struct.std::array"*, double*)* @_Z6squarePd to i8*), i32 noundef %3, i32 noundef 4, double* noundef nonnull %x, <4 x double>* noundef nonnull %dx)
  %arrayidx.i.i = getelementptr inbounds %"struct.std::array.0", %"struct.std::array.0"* %ref.tmp, i64 0, i32 0, i64 0
  %4 = load <4 x double>, <4 x double>* %arrayidx.i.i, align 32
  %vecext = extractelement <4 x double> %4, i64 0
  %call1 = call i32 (i8*, ...) @printf(i8* noundef nonnull dereferenceable(1) getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i64 0, i64 0), double noundef %vecext)
  call void @llvm.lifetime.end.p0i8(i64 96, i8* nonnull %2) #6
  call void @llvm.lifetime.end.p0i8(i64 32, i8* nonnull %1) #6
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0) #6
  ret i32 0
}

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #4

declare dso_local noundef i32 @printf(i8* nocapture noundef readonly, ...) local_unnamed_addr #5

declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #4

attributes #0 = { mustprogress nofree norecurse nosync nounwind uwtable willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+crc32,+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "tune-cpu"="generic" }
attributes #1 = { mustprogress uwtable "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+crc32,+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "tune-cpu"="generic" }
attributes #2 = { "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+crc32,+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "tune-cpu"="generic" }
attributes #3 = { mustprogress norecurse uwtable "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+crc32,+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "tune-cpu"="generic" }
attributes #4 = { argmemonly mustprogress nofree nosync nounwind willreturn }
attributes #5 = { nofree nounwind "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+avx,+avx2,+crc32,+cx8,+fxsr,+mmx,+popcnt,+sse,+sse2,+sse3,+sse4.1,+sse4.2,+ssse3,+x87,+xsave" "tune-cpu"="generic" }
attributes #6 = { nounwind }


; CHECK: define internal void @fwddiffe4_Z6squarePd(%"struct.std::array"* noalias nocapture writeonly align 8 %agg.result, %"struct.std::array.Vec.4"* %"agg.result'", double* nocapture noundef readonly %x, <4 x double>* %"x'")
; CHECK-NEXT:  entry:
; CHECK-NEXT:   %"arrayinit.begin'ipg" = getelementptr inbounds %"struct.std::array.Vec.4", %"struct.std::array.Vec.4"* %"agg.result'", i64 0, i32 0, i64 0
; CHECK-NEXT:   %arrayinit.begin = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 0
; CHECK-NEXT:   %"'ipl" = load <4 x double>, <4 x double>* %"x'", align 8
; CHECK-NEXT:   %0 = load double, double* %x, align 8
; CHECK-NEXT:   %mul = fmul double %0, %0
; CHECK-NEXT:   %.splatinsert = insertelement <4 x double> poison, double %0, i32 0
; CHECK-NEXT:   %.splat = shufflevector <4 x double> %.splatinsert, <4 x double> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:   %1 = fmul fast <4 x double> %"'ipl", %.splat
; CHECK-NEXT:   %2 = fadd fast <4 x double> %1, %1
; CHECK-NEXT:   store double %mul, double* %arrayinit.begin, align 8
; CHECK-NEXT:   store <4 x double> %2, <4 x double>* %"arrayinit.begin'ipg", align 8
; CHECK-NEXT:   %"arrayinit.element'ipg" = getelementptr inbounds %"struct.std::array.Vec.4", %"struct.std::array.Vec.4"* %"agg.result'", i64 0, i32 0, i64 1
; CHECK-NEXT:   %arrayinit.element = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 1
; CHECK-NEXT:   %mul2 = fmul double %0, %mul
; CHECK-NEXT:   %.splatinsert5 = insertelement <4 x double> poison, double %mul, i32 0
; CHECK-NEXT:   %.splat6 = shufflevector <4 x double> %.splatinsert5, <4 x double> poison, <4 x i32> zeroinitializer
; CHECK-NEXT:   %3 = fmul fast <4 x double> %"'ipl", %.splat6
; CHECK-NEXT:   %4 = fmul fast <4 x double> %2, %.splat
; CHECK-NEXT:   %5 = fadd fast <4 x double> %3, %4
; CHECK-NEXT:   store double %mul2, double* %arrayinit.element, align 8
; CHECK-NEXT:   store <4 x double> %5, <4 x double>* %"arrayinit.element'ipg", align 8
; CHECK-NEXT:   %"arrayinit.element3'ipg" = getelementptr inbounds %"struct.std::array.Vec.4", %"struct.std::array.Vec.4"* %"agg.result'", i64 0, i32 0, i64 2
; CHECK-NEXT:   %arrayinit.element3 = getelementptr inbounds %"struct.std::array", %"struct.std::array"* %agg.result, i64 0, i32 0, i64 2
; CHECK-NEXT:   store double %0, double* %arrayinit.element3, align 8
; CHECK-NEXT:   store <4 x double> %"'ipl", <4 x double>* %"arrayinit.element3'ipg", align 8
; CHECK-NEXT:   ret void
; CHECK-NEXT: }