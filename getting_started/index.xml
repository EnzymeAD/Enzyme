<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Getting Started on Enzyme AD</title><link>https://enzyme.mit.edu/getting_started/</link><description>Recent content in Getting Started on Enzyme AD</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://enzyme.mit.edu/getting_started/index.xml" rel="self" type="application/rss+xml"/><item><title>CUDA Guide</title><link>https://enzyme.mit.edu/getting_started/CUDAGuide/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/CUDAGuide/</guid><description>Reference C++ example WARNING: CUDA support is highly experimental and in active development.
Suppose we wanted to port the following C++ code to CUDA, with Enzyme autodiff support:
#include &amp;lt;stdio.h&amp;gt; void foo(double* x_in, double *x_out) { x_out[0] = x_in[0] * x_in[0]; } int enzyme_dup; int enzyme_out; int enzyme_const; typedef void (*f_ptr)(double*, double*); extern void __enzyme_autodiff(f_ptr, int, double*, double*, int, double*, double*); int main() { double x = 1.4; double d_x = 0.</description></item><item><title>Using Enzyme</title><link>https://enzyme.mit.edu/getting_started/UsingEnzyme/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/UsingEnzyme/</guid><description>Generating LLVM To begin, let&amp;rsquo;s create a simple code test.c we want to differentiate. Enzyme will replace any calls to functions whose names contain &amp;ldquo;__enzyme_autodiff&amp;rdquo; with calls to the corresponding For now, let&amp;rsquo;s ignore the details of Enzyme&amp;rsquo;s calling convention/ABI which are described in detail here // test.c #include &amp;lt;stdio.h&amp;gt;extern double __enzyme_autodiff(void*, double); double square(double x) { return x * x; } double dsquare(double x) { // This returns the derivative of square or 2 * x return __enzyme_autodiff((void*) square, x); } int main() { for(double i=1; i&amp;lt;5; i++) printf(&amp;#34;square(%f)=%f, dsquare(%f)=%f&amp;#34;, i, square(i), i, dsquare(i)); } We can generate LLVM from this code by calling clang as follows.</description></item><item><title>Calling Convention</title><link>https://enzyme.mit.edu/getting_started/CallingConvention/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/CallingConvention/</guid><description>Enzyme is invoked by calling a function __enzyme_autodiff with the function being differentiated, followed by the corresponding primal and shadow arguments. This will result in the original function being run with the corresponding derivative values being computed.
Function Hooks Enzyme replaces all calls to functions that contain the string __enzyme_autodiff with a call to the corresponding derivative. This is done to allow Enzyme to register multiple function signatures.
#include &amp;lt;stdio.h&amp;gt;template&amp;lt;typename T&amp;gt; T square(T x) { return x * x; } float __enzyme_autodiffFloat(float (*)(float), float); double __enzyme_autodiffDouble(double (*)(double), double); int main() { printf(&amp;#34;float d/dx %f\n&amp;#34;, __enzyme_autodiffFloat(square&amp;lt;float&amp;gt;, 1.</description></item><item><title>FAQ</title><link>https://enzyme.mit.edu/getting_started/Faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/Faq/</guid><description>Enzyme builds successfully but won&amp;rsquo;t run tests Double check that Enzyme&amp;rsquo;s build can find lit, LLVM&amp;rsquo;s testing framework. This can be done by explicitly passing lit as an argument to CMake as described here .
Enzyme is Crashing LLVM&amp;rsquo;s plugin infrastructure is broken in many versions. Empirically LLVM 8 and up will often incorrectly disallow memory from being passed between LLVM and a plugin. If you see one of these errors and want to use the same version of LLVM try passing the flag enzyme_preopt=0 described here .</description></item></channel></rss>