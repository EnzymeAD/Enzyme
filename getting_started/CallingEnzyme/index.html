<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Calling Enzyme - Enzyme AD</title><meta name=description content="Enzyme Automatic Differentiation Framework"><meta name=generator content="Hugo 0.74.3"><link href=//enzyme.mit.edu/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=//enzyme.mit.edu/getting_started/CallingEnzyme/><link rel=stylesheet href=//enzyme.mit.edu/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=//enzyme.mit.edu/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=//enzyme.mit.edu/js/bundle.js></script><link rel=icon href=/favicon.ico type=image/x-icon><style>:root{}</style></head><body><div class=container><header><h1><div><img src=//enzyme.mit.edu//logo.svg width=40px align=absmiddle>
Enzyme AD</div></h1><p class=description>Enzyme Automatic Differentiation Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://groups.google.com/d/forum/enzyme-dev>Discussion List</a></li></ul></li><li class=parent><a href=https://github.com/wsmoses/Enzyme>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/wsmoses/Enzyme>GitHub</a></li></ul></li><li><a href=https://github.com/wsmoses/Enzyme/issues>Bugs</a></li><li><a href=/getting_started/Faq/>FAQ</a></li></ul></nav></div><div class=content-container><main><h1>Calling Enzyme</h1><h2 id=generating-llvm>Generating LLVM&nbsp;<a class=headline-hash href=#generating-llvm>¶</a></h2><p>To begin, let&rsquo;s create a simple code <code>test.c</code> we want to differentiate. Enzyme will replace any calls to functions whose names start as &ldquo;__enzyme_autodiff&rdquo; with calls to the corresponding For now, let&rsquo;s ignore the details of Enzyme&rsquo;s calling convention/ABI which are described in detail
<a href=/getting_started/calling_convention>here</a></p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// test.c
</span><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=k>extern</span> <span class=kt>double</span> <span class=nf>__enzyme_autodiff</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=kt>double</span><span class=p>);</span>
<span class=kt>double</span> <span class=nf>square</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
<span class=p>}</span>
<span class=kt>double</span> <span class=nf>dsquare</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>__enzyme_autodiff</span><span class=p>(</span><span class=n>square</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
<span class=p>}</span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>for</span><span class=p>(</span><span class=kt>double</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;square(%f)=%f, dsquare(%f)=%f&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>square</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>i</span><span class=p>,</span> <span class=n>dsquare</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div><p>We can generate LLVM from this code by calling clang as follows. Note that <code>clang</code> should be the path to whatever clang you built Enzyme against.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>clang test.c -S -emit-llvm -o input.ll -O2 -fno-vectorize -fno-slp-vectorize -fno-unroll-loops
</code></pre></div><p>The arguments <code>-S -emit-llvm</code> specify that we want to emit LLVM bitcode rather than an executable. The arguments <code>-o input.ll</code> specify that we want the output to be in a file <code>input.ll</code>. The argument <code>-O2 -ffast-math</code> runs optimizations (with fast-math) before we run Enzyme&rsquo;s AD process, which is often beneficial for performance. The argument <code>-fno-vectorize -fno-slp-vectorize -fno-unroll-loops</code> specifies that we don&rsquo;t want to run vectorization or loop unrolling. In practice, it is better for performance to only run these scheduling optimizations after AD.</p><p>The generated LLVM IR should look something like the following</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=c>; input.ll
</span><span class=c></span><span class=p>...</span>
<span class=k>define</span> <span class=err>dso_local</span> <span class=kt>double</span> <span class=vg>@square</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>)</span> <span class=vg>#0</span> <span class=p>{</span>
<span class=nl>entry:</span>
  <span class=nv>%mul</span> <span class=p>=</span> <span class=k>fmul</span> <span class=kt>double</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%x</span>
  <span class=k>ret</span> <span class=kt>double</span> <span class=nv>%mul</span>
<span class=p>}</span>

<span class=k>define</span> <span class=err>dso_local</span> <span class=kt>double</span> <span class=vg>@dsquare</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>)</span> <span class=k>local_unnamed_addr</span> <span class=vg>#1</span> <span class=p>{</span>
<span class=nl>entry:</span>
  <span class=nv>%call</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=kt>double</span> <span class=vg>@__enzyme_autodiff</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>bitcast</span> <span class=p>(</span><span class=kt>double</span> <span class=p>(</span><span class=kt>double</span><span class=p>)*</span> <span class=vg>@square</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*),</span> <span class=kt>double</span> <span class=nv>%x</span><span class=p>)</span> <span class=vg>#4</span>
  <span class=k>ret</span> <span class=kt>double</span> <span class=nv>%call</span>
<span class=p>}</span>
<span class=p>...</span>
</code></pre></div><h2 id=performing-ad-enzyme>Performing AD Enzyme&nbsp;<a class=headline-hash href=#performing-ad-enzyme>¶</a></h2><p>We can now run Enzyme to differentiate our LLVM IR. The following command will load Enzyme and run the differentiation transformation pass. Note that <code>opt</code> should be the path to whatever opt was creating by the LLVM you built Enzyme against. If you see a segfault when trying to run opt, this is likely an issue in LLVM&rsquo;s plugin infrasture. Please see
<a href=/getting_started/Installation/>the installation guide</a>
for more information on how to resolve this.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>opt input.ll -load<span class=o>=</span>/path/to/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-&lt;VERSION&gt;.so -enzyme -o output.ll -S
</code></pre></div><p>Taking a look at <code>output.ll</code>, we find the following:</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=c>; output.ll
</span><span class=c></span><span class=k>define</span> <span class=k>internal</span> <span class=p>{</span> <span class=kt>double</span> <span class=p>}</span> <span class=vg>@diffesquare</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>,</span> <span class=kt>double</span> <span class=nv>%differeturn</span><span class=p>)</span> <span class=vg>#0</span> <span class=p>{</span>
<span class=nl>entry:</span>
  <span class=nv>%&#34;mul&#39;de&#34;</span> <span class=p>=</span> <span class=k>alloca</span> <span class=kt>double</span>
  <span class=k>store</span> <span class=kt>double</span> <span class=m>0.000000e+00</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;mul&#39;de&#34;</span>
  <span class=nv>%&#34;x&#39;de&#34;</span> <span class=p>=</span> <span class=k>alloca</span> <span class=kt>double</span>
  <span class=k>store</span> <span class=kt>double</span> <span class=m>0.000000e+00</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=k>br</span> <span class=kt>label</span> <span class=nv>%invertentry</span>

<span class=nl>invertentry:</span>                                      <span class=c>; preds = %entry
</span><span class=c></span>  <span class=k>store</span> <span class=kt>double</span> <span class=nv>%differeturn</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;mul&#39;de&#34;</span>
  <span class=n>%0</span> <span class=p>=</span> <span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;mul&#39;de&#34;</span>
  <span class=nv>%m0diffex</span> <span class=p>=</span> <span class=k>fmul</span> <span class=k>fast</span> <span class=kt>double</span> <span class=n>%0</span><span class=p>,</span> <span class=nv>%x</span>
  <span class=nv>%m1diffex</span> <span class=p>=</span> <span class=k>fmul</span> <span class=k>fast</span> <span class=kt>double</span> <span class=n>%0</span><span class=p>,</span> <span class=nv>%x</span>
  <span class=k>store</span> <span class=kt>double</span> <span class=m>0.000000e+00</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;mul&#39;de&#34;</span>
  <span class=n>%1</span> <span class=p>=</span> <span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=n>%2</span> <span class=p>=</span> <span class=k>fadd</span> <span class=k>fast</span> <span class=kt>double</span> <span class=n>%1</span><span class=p>,</span> <span class=nv>%m0diffex</span>
  <span class=k>store</span> <span class=kt>double</span> <span class=n>%2</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=n>%3</span> <span class=p>=</span> <span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=n>%4</span> <span class=p>=</span> <span class=k>fadd</span> <span class=k>fast</span> <span class=kt>double</span> <span class=n>%3</span><span class=p>,</span> <span class=nv>%m1diffex</span>
  <span class=k>store</span> <span class=kt>double</span> <span class=n>%4</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=n>%5</span> <span class=p>=</span> <span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=nv>%&#34;x&#39;de&#34;</span>
  <span class=n>%6</span> <span class=p>=</span> <span class=k>insertvalue</span> <span class=p>{</span> <span class=kt>double</span> <span class=p>}</span> <span class=k>undef</span><span class=p>,</span> <span class=kt>double</span> <span class=n>%5</span><span class=p>,</span> <span class=m>0</span>
  <span class=k>ret</span> <span class=p>{</span> <span class=kt>double</span> <span class=p>}</span> <span class=n>%6</span>
<span class=p>}</span>

<span class=k>define</span> <span class=err>dso_local</span> <span class=kt>double</span> <span class=vg>@dsquare</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>)</span> <span class=k>local_unnamed_addr</span> <span class=vg>#1</span> <span class=p>{</span>
<span class=nl>entry:</span>
  <span class=n>%0</span> <span class=p>=</span> <span class=k>call</span> <span class=p>{</span> <span class=kt>double</span> <span class=p>}</span> <span class=vg>@diffesquare</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>,</span> <span class=kt>double</span> <span class=m>1.000000e+00</span><span class=p>)</span>
  <span class=n>%1</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span> <span class=p>}</span> <span class=n>%0</span><span class=p>,</span> <span class=m>0</span>
  <span class=k>ret</span> <span class=kt>double</span> <span class=n>%1</span>
<span class=p>}</span>
</code></pre></div><p>Enzyme has created a new gradient function and replaced the corresponding call to <code>__enzyme_autodiff</code>. Note that newly-created gradient function isn&rsquo;t yet optimized. Enzyme assumes that various post-processing will occur after creating the gradient.</p><p>For example, suppose we run <code>-O2</code> after Enzyme as shown below:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>opt input.ll -load<span class=o>=</span>/path/to/Enzyme/enzyme/build/Enzyme/LLVMEnzyme-&lt;VERSION&gt;.so -enzyme -o output_opt.ll -S
</code></pre></div><p>Taking a look at <code>output_opt.ll</code>, we see the following:</p><div class=highlight><pre class=chroma><code class=language-llvm data-lang=llvm><span class=c>; output_opt.ll
</span><span class=c></span><span class=k>define</span> <span class=err>dso_local</span> <span class=kt>double</span> <span class=vg>@dsquare</span><span class=p>(</span><span class=kt>double</span> <span class=nv>%x</span><span class=p>)</span> <span class=k>local_unnamed_addr</span> <span class=vg>#0</span> <span class=p>{</span>
<span class=nl>entry:</span>
  <span class=nv>%factor.i</span> <span class=p>=</span> <span class=k>fmul</span> <span class=k>fast</span> <span class=kt>double</span> <span class=nv>%x</span><span class=p>,</span> <span class=m>2.000000e+00</span>
  <span class=k>ret</span> <span class=kt>double</span> <span class=nv>%factor.i</span>
<span class=p>}</span>
</code></pre></div><p>The generated gradient has been inlined and entirely simplified to return the input times two.</p><h2 id=advanced-options>Advanced options&nbsp;<a class=headline-hash href=#advanced-options>¶</a></h2><p>Enzyme has several advanced options that may be of interest.</p><h3 id=performance-options>Performance options&nbsp;<a class=headline-hash href=#performance-options>¶</a></h3><h4 id=disabling-preprocessing>Disabling Preprocessing&nbsp;<a class=headline-hash href=#disabling-preprocessing>¶</a></h4><p>The <code>enzyme_preopt</code> option disables the preprocessing optimizations run by the Enzyme pass, except for the absolute minimum neccessary.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_preopt<span class=o>=</span><span class=m>1</span>
$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_preopt<span class=o>=</span><span class=m>0</span>
</code></pre></div><h4 id=forced-inlining>Forced Inlining&nbsp;<a class=headline-hash href=#forced-inlining>¶</a></h4><p>The <code>enzyme_inline</code> option forcibly inlines all subfunction calls. The <code>enzyme_inline_count</code> option limits the number of calls inlined by this utility.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_inline<span class=o>=</span><span class=m>1</span>
$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_inline<span class=o>=</span><span class=m>1</span> -enzyme_inline_count<span class=o>=</span><span class=m>100</span>
</code></pre></div><h4 id=compressed-bool-cache>Compressed Bool Cache&nbsp;<a class=headline-hash href=#compressed-bool-cache>¶</a></h4><p>The <code>enzyme_smallbool</code> option allows Enzyme&rsquo;s cache to store 8 boolean (i1) values inside a single byte rather than one value per byte.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_smallbool<span class=o>=</span><span class=m>1</span>
</code></pre></div><h3 id=semantic-options>Semantic options&nbsp;<a class=headline-hash href=#semantic-options>¶</a></h3><h4 id=loose-type-analysis>Loose type analysis&nbsp;<a class=headline-hash href=#loose-type-analysis>¶</a></h4><p>The <code>enzyme_loosetypes</code> option tells Enzyme to make an educated guess about the type of a value it cannot prove, rather than emit a compile-time error and fail. This can be helpful for starting to bootstrap code with Enzyme but shouldn&rsquo;t be used in production as Enzyme may make an incorrect guess and create an incorrect gradient.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_loosetypes<span class=o>=</span><span class=m>1</span>
</code></pre></div><h4 id=assume-inactivity-of-undefined-functions>Assume inactivity of undefined functions&nbsp;<a class=headline-hash href=#assume-inactivity-of-undefined-functions>¶</a></h4><p>The <code>enzyme_emptyfnconst</code> option tells activity analysis to assume that all calls to functions whose definitions aren&rsquo;t available and aren&rsquo;t explicitly given a custom gradient via metadata are assumed to be inactive. This can be useful for assuming printing functions don&rsquo;t impact derivative computations and provide a performance benefit, as well as getting around a compile-time error where the derivative of a foreign function is not known. However, this option should be used carefully as it may result in incorrect behavior if it is used to incorrectly assume a call to a foreign function doesn&rsquo;t impact the derivative computation. As a result, the recommended way to remedy this is to mark the function as inactive explicitly, or provide a custom gradient via metadata.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_emptyfnconst<span class=o>=</span><span class=m>1</span>
</code></pre></div><h4 id=assume-inactivity-of-unmarked-globals>Assume inactivity of unmarked globals&nbsp;<a class=headline-hash href=#assume-inactivity-of-unmarked-globals>¶</a></h4><p>The <code>enzyme_nonmarkedglobals_inactive</code> option tells activity analysis to assume that global variables without an explicitly defined shadow global are assumed to be inactive. Like <code>enzyme_emptyfnconst</code>, this option should be used carefully as it may result in incorrect behavior if it is used to incorrectly assume that a global variable doesn&rsquo;t contain data used in a derivative computation.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_nonmarkedglobals_inactive<span class=o>=</span><span class=m>1</span>
</code></pre></div><h4 id=cache-behavior>Cache behavior&nbsp;<a class=headline-hash href=#cache-behavior>¶</a></h4><p>The <code>enzyme_never_cache_reads</code> option tells the cache to recompute all load values, even if alias analysis isn&rsquo;t able to prove the legality of such a recomputation. This may improve performance but is likely to result in incorrect derivatives being produced as this is not generally true.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_never_cache_reads<span class=o>=</span><span class=m>1</span>
</code></pre></div><p>In contrast, the <code>enzyme_always_cache_reads</code> option tells the cache to still cache values that alias analysis and differential use analysis say are not needed to be cached (perhaps being legal to recompute instead). This will usually decrease performance and is intended for developers in order to catch caching bugs.</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>$ opt input.ll -load<span class=o>=</span>./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_always_cache_reads<span class=o>=</span><span class=m>1</span>
</code></pre></div><h3 id=debugging-options-for-developers>Debugging options for developers&nbsp;<a class=headline-hash href=#debugging-options-for-developers>¶</a></h3><h4 id=enzyme_print>enzyme_print&nbsp;<a class=headline-hash href=#enzyme_print>¶</a></h4><p>This option prints out functions being differentiated before preprocessing optimizations, after preprocessing optimizations, and after being synthesized by Enzyme. It is mostly use to debug the AD process.</p><pre><code>$ opt input.ll -load=./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_print
prefn:

; Function Attrs: norecurse nounwind readnone uwtable
define dso_local double @square(double %x) #0 {
entry:
  %mul = fmul double %x, %x
  ret double %mul
}
</code></pre><h4 id=enzyme_printconst>enzyme_printconst&nbsp;<a class=headline-hash href=#enzyme_printconst>¶</a></h4><p>This option prints out the results of activity analysis as they are being derived. The output is somewaht specific to the analysis pass and is only intended for developers.</p><pre><code>$ opt input.ll -load=./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_printconst
in new function diffesquare nonconstant arg double %0
 VALUE nonconst from arg nonconst double %x
checking if is constant[3]   %mul = fmul double %x, %x
 &lt; UPSEARCH3&gt;  %mul = fmul double %x, %x
 VALUE nonconst from arg nonconst double %x
nonconstant(3)  up-inst   %mul = fmul double %x, %x op double %x
 &lt;/UPSEARCH3&gt;  %mul = fmul double %x, %x
couldnt decide nonconstants(3):  %mul = fmul double %x, %x
 Value nonconstant (couldn't disprove)[3]  %mul = fmul double %x, %x
</code></pre><h4 id=enzyme_printtype>enzyme_printtype&nbsp;<a class=headline-hash href=#enzyme_printtype>¶</a></h4><p>This option prints out the results of type analysis as they are being derived. The output is somewaht specific to the analysis pass and is only intended for developers.</p><pre><code>$ opt input.ll -load=./Enzyme/LLVMEnzyme-7.so -enzyme -enzyme_printtype
analyzing function square
 + knowndata: double %x : {[-1]:Float@double} - {}
 + retdata: {}
updating analysis of val: double %x current: {} new {[-1]:Float@double}
updating analysis of val: double %x current: {[-1]:Float@double} new {[-1]:Float@double} from double %x
updating analysis of val:   %mul = fmul double %x, %x current: {} new {}
updating analysis of val: double %x current: {[-1]:Float@double} new {[-1]:Float@double} from   %mul = fmul double %x, %x
updating analysis of val: double %x current: {[-1]:Float@double} new {[-1]:Float@double} from   %mul = fmul double %x, %x
updating analysis of val:   %mul = fmul double %x, %x current: {} new {[-1]:Float@double} from   %mul = fmul double %x, %x
</code></pre><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/getting_started/Installation/ title=Installation><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Installation</a>
<a class="nav nav-next" href=/getting_started/CallingConvention/ title="Calling Convention">Next - Calling Convention <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=//enzyme.mit.edu/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li class="parent has-sub-menu"><a href=/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/getting_started/Installation/>Installation</a></li><li class=active><a href=/getting_started/CallingEnzyme/>Calling Enzyme</a></li><li><a href=/getting_started/CallingConvention/>Calling Convention</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>