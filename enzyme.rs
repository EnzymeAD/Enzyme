/* automatically generated by rust-bindgen 0.59.2 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int64_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueType {
    _unused: [u8; 0],
}
#[doc = " Each value in the LLVM IR has a type, an LLVMTypeRef."]
#[doc = ""]
#[doc = " @see llvm::Type"]
pub type LLVMTypeRef = *mut LLVMOpaqueType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueValue {
    _unused: [u8; 0],
}
#[doc = " Represents an individual value in LLVM IR."]
#[doc = ""]
#[doc = " This models llvm::Value."]
pub type LLVMValueRef = *mut LLVMOpaqueValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueTypeAnalysis {
    _unused: [u8; 0],
}
pub type EnzymeTypeAnalysisRef = *mut EnzymeOpaqueTypeAnalysis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueLogic {
    _unused: [u8; 0],
}
pub type EnzymeLogicRef = *mut EnzymeOpaqueLogic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeOpaqueAugmentedReturn {
    _unused: [u8; 0],
}
pub type EnzymeAugmentedReturnPtr = *mut EnzymeOpaqueAugmentedReturn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntList {
    pub data: *mut i64,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_IntList() {
    assert_eq!(
        ::std::mem::size_of::<IntList>(),
        16usize,
        concat!("Size of: ", stringify!(IntList))
    );
    assert_eq!(
        ::std::mem::align_of::<IntList>(),
        8usize,
        concat!("Alignment of ", stringify!(IntList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntList>())).data as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(IntList), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IntList>())).size as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(IntList), "::", stringify!(size))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CConcreteType {
    DT_Anything = 0,
    DT_Integer = 1,
    DT_Pointer = 2,
    DT_Half = 3,
    DT_Float = 4,
    DT_Double = 5,
    DT_Unknown = 6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EnzymeTypeTree {
    _unused: [u8; 0],
}
pub type CTypeTreeRef = *mut EnzymeTypeTree;
extern "C" {
    pub fn EnzymeNewTypeTree() -> CTypeTreeRef;
}
extern "C" {
    pub fn EnzymeFreeTypeTree(CTT: CTypeTreeRef);
}
extern "C" {
    pub fn EnzymeSetCLBool(arg1: *mut ::std::os::raw::c_void, arg2: u8);
}
extern "C" {
    pub fn EnzymeSetCLInteger(arg1: *mut ::std::os::raw::c_void, arg2: i64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFnTypeInfo {
    #[doc = " Types of arguments, assumed of size len(Arguments)"]
    pub Arguments: *mut CTypeTreeRef,
    #[doc = " Type of return"]
    pub Return: CTypeTreeRef,
    #[doc = " The specific constant(s) known to represented by an argument, if constant"]
    pub KnownValues: *mut IntList,
}
#[test]
fn bindgen_test_layout_CFnTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CFnTypeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CFnTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CFnTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CFnTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).Arguments as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CFnTypeInfo), "::", stringify!(Arguments))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).Return as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(CFnTypeInfo), "::", stringify!(Return))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CFnTypeInfo>())).KnownValues as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(CFnTypeInfo), "::", stringify!(KnownValues))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CDIFFE_TYPE {
    DFT_OUT_DIFF = 0,
    DFT_DUP_ARG = 1,
    DFT_CONSTANT = 2,
    DFT_DUP_NONEED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum CDerivativeMode {
    DEM_ForwardMode = 0,
    DEM_ReverseModePrimal = 1,
    DEM_ReverseModeGradient = 2,
    DEM_ReverseModeCombined = 3,
    DEM_ForwardModeSplit = 4,
}
extern "C" {
    pub fn EnzymeCreateForwardDiff(
        arg1: EnzymeLogicRef,
        todiff: LLVMValueRef,
        retType: CDIFFE_TYPE,
        constant_args: *mut CDIFFE_TYPE,
        constant_args_size: size_t,
        TA: EnzymeTypeAnalysisRef,
        returnValue: u8,
        mode: CDerivativeMode,
        freeMemory: u8,
        width: ::std::os::raw::c_uint,
        additionalArg: LLVMTypeRef,
        typeInfo: CFnTypeInfo,
        _uncacheable_args: *mut u8,
        uncacheable_args_size: size_t,
        augmented: EnzymeAugmentedReturnPtr,
    ) -> LLVMValueRef;
}
extern "C" {
    pub fn EnzymeCreatePrimalAndGradient(
        arg1: EnzymeLogicRef,
        todiff: LLVMValueRef,
        retType: CDIFFE_TYPE,
        constant_args: *mut CDIFFE_TYPE,
        constant_args_size: size_t,
        TA: EnzymeTypeAnalysisRef,
        returnValue: u8,
        dretUsed: u8,
        mode: CDerivativeMode,
        width: ::std::os::raw::c_uint,
        freeMemory: u8,
        additionalArg: LLVMTypeRef,
        typeInfo: CFnTypeInfo,
        _uncacheable_args: *mut u8,
        uncacheable_args_size: size_t,
        augmented: EnzymeAugmentedReturnPtr,
        AtomicAdd: u8,
    ) -> LLVMValueRef;
}
extern "C" {
    pub fn EnzymeCreateAugmentedPrimal(
        arg1: EnzymeLogicRef,
        todiff: LLVMValueRef,
        retType: CDIFFE_TYPE,
        constant_args: *mut CDIFFE_TYPE,
        constant_args_size: size_t,
        TA: EnzymeTypeAnalysisRef,
        returnUsed: u8,
        shadowReturnUsed: u8,
        typeInfo: CFnTypeInfo,
        _uncacheable_args: *mut u8,
        uncacheable_args_size: size_t,
        forceAnonymousTape: u8,
        width: ::std::os::raw::c_uint,
        AtomicAdd: u8,
    ) -> EnzymeAugmentedReturnPtr;
}
pub type CustomRuleType = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: CTypeTreeRef,
        arg3: *mut CTypeTreeRef,
        arg4: *mut IntList,
        arg5: size_t,
        arg6: LLVMValueRef,
    ) -> u8,
>;
extern "C" {
    pub fn CreateTypeAnalysis(
        Log: EnzymeLogicRef,
        customRuleNames: *mut *mut ::std::os::raw::c_char,
        customRules: *mut CustomRuleType,
        numRules: size_t,
    ) -> EnzymeTypeAnalysisRef;
}
extern "C" {
    pub fn ClearTypeAnalysis(arg1: EnzymeTypeAnalysisRef);
}
extern "C" {
    pub fn FreeTypeAnalysis(arg1: EnzymeTypeAnalysisRef);
}
extern "C" {
    pub fn CreateEnzymeLogic(PostOpt: u8) -> EnzymeLogicRef;
}
extern "C" {
    pub fn ClearEnzymeLogic(arg1: EnzymeLogicRef);
}
extern "C" {
    pub fn FreeEnzymeLogic(arg1: EnzymeLogicRef);
}
