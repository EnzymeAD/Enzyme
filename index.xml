<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Enzyme AD</title><link>//enzyme.mit.edu/</link><description>Recent content on Enzyme AD</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="//enzyme.mit.edu/index.xml" rel="self" type="application/rss+xml"/><item><title>Installation</title><link>//enzyme.mit.edu/Installation/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>//enzyme.mit.edu/Installation/</guid><description>Downloading Enzyme To start you should download Enzyme&amp;rsquo;s code Github .
git clone https://github.com/wsmoses/Enzyme cd Enzyme Building LLVM Enzyme is a plugin for LLVM and consequently needs an existing build of LLVM to function. You can either build the fork of LLVM-7 available inside of Enzyme&amp;rsquo;s repository (this allows you to use custom C/C++ syntactic sugar for calling Enzyme), or your choice of an existing build of LLVM.
Enzyme is designed to work with a wide range of LLVM versions and is currently tested against LLVM 6, 7, 8 and 9.</description></item><item><title>Calling Enzyme</title><link>//enzyme.mit.edu/getting_started/CallingEnzyme/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>//enzyme.mit.edu/getting_started/CallingEnzyme/</guid><description>Generating LLVM To begin, let&amp;rsquo;s create a simple code test.c we want to differentiate. Enzyme will replace any calls to functions whose names contain &amp;ldquo;__enzyme_autodiff&amp;rdquo; with calls to the corresponding For now, let&amp;rsquo;s ignore the details of Enzyme&amp;rsquo;s calling convention/ABI which are described in detail here // test.c #include &amp;lt;stdio.h&amp;gt;extern double __enzyme_autodiff(void*, double); double square(double x) { return x * x; } double dsquare(double x) { return __enzyme_autodiff(square, x); } int main() { for(double i=1; i&amp;lt;5; i++) printf(&amp;#34;square(%f)=%f, dsquare(%f)=%f&amp;#34;, i, square(i), i, dsquare(i)); } We can generate LLVM from this code by calling clang as follows.</description></item><item><title>Calling Convention</title><link>//enzyme.mit.edu/getting_started/CallingConvention/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>//enzyme.mit.edu/getting_started/CallingConvention/</guid><description>Calling Convention Enzyme is invoked by calling a function __enzyme_autodiff with the function being differentiated, followed by the corresponding primal and shadow arguments. This will result in the original function being run with the corresponding derivative values being computed.
Function Hooks Enzyme replaces all calls to functions that contain the string __enzyme_autodiff with a call to the corresponding derivative. This is done to allow Enzyme to register multiple function signatures.</description></item><item><title>FAQ</title><link>//enzyme.mit.edu/getting_started/Faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>//enzyme.mit.edu/getting_started/Faq/</guid><description>What is &amp;hellip;? TODO</description></item></channel></rss>